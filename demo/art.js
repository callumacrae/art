(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
window.normalLines = require('./normal-lines');
window.perimetros = require('./perimetros');

},{"./normal-lines":9,"./perimetros":11}],2:[function(require,module,exports){
const random = require('./random');

/**
 * Stores the x and y dimensions of a euclidean vector in the cartesian plane
 * and provides some useful helper functions.
 *
 * @param {number} ax The x dimension of the vector.
 * @param {number} ay The y dimension.
 * @constructor
 */
function Vector(ax, ay) {
	if (!(this instanceof Vector)) {
		return new Vector(ax, ay);
	}

	this.ax = ax;
	this.ay = ay;
}

/**
 * Calculates the magnitude of the vector.
 *
 * @returns {number} The magnitude of the vector.
 */
Vector.prototype.getMagnitude = function () {
	return Math.pow(Math.pow(this.ax, 2) + Math.pow(this.ay, 2), 0.5);
};

/**
 * Returns a new vector with a specified magnitude.
 *
 * @param {number} newMagnitude The magnitude of the new vector.
 * @returns {Vector} A new vector with specified magnitude.
 */
Vector.prototype.restrictMagnitude = function (newMagnitude) {
	const ratio = newMagnitude / this.getMagnitude();

	return new Vector(this.ax * ratio, this.ay * ratio);
};

/**
 * Changes a vector slightly by a random amount. Uses a random function with a
 * normal distribution, so it's usually not that different.
 *
 * @param {number} [factor=1] Standard deviation of the normal distribution
 * function used.
 * @returns {Vector} Slightly different vector.
 */
Vector.prototype.randomiseByFactor = function (factor = 1) {
	return new Vector(this.ax + random.normal() * factor, this.ay + random.normal() * factor);
};

/**
 * Calculates the vector between two coordinates
 *
 * @param {Coord} from Coordinate to calculate vector from
 * @param {Coord} to Coordinate to calculate vector to
 */
Vector.between = function (from, to) {
	return new Vector(to.x - from.x, to.y - from.y);
};

/**
 * Returns the average of n vectors.
 *
 * @param {...Vector} vectors One or more vectors.
 * @returns {Vector} The average vector.
 */
Vector.average = function (...vectors) {
	const ax = vectors.reduce((sum, { ax }) => sum + ax, 0) / vectors.length;
	const ay = vectors.reduce((sum, { ay }) => sum + ay, 0) / vectors.length;

	return new Vector(ax, ay);
};

/**
 * Generates a random vector going < 0.5 on the x and y axes.
 *
 * @returns {Vector} Random vector.
 */
Vector.random = function () {
	return new Vector(random(), random());
};

/**
 * Generate a vector from the direction and magnitude instead of from the
 * components.
 *
 * @param {number} direction Direction in radians.
 * @param {number} magnitude Magnitude of the vector.
 * @returns {Vector} Generated vector.
 */
Vector.fromDirection = function (direction, magnitude = 1) {
	const ax = magnitude * Math.cos(direction);
	const ay = magnitude * Math.sin(direction);
	return new Vector(ax, ay);
};

module.exports = Vector;

},{"./random":6}],3:[function(require,module,exports){
const Coord = require('./coord');

/**
 * A small wrapper function so that we don't have to mix canvas logic randomly
 * in the rest of the code. Basically makes everything testable.
 *
 * @param {string} selector The element to draw onto.
 * @constructor
 */
function Canvas(selector) {
	this._canvas = document.querySelector(selector);
	this._context = this._canvas.getContext('2d');

	this.origin = new Coord(this._canvas.width / 2, this._canvas.height / 2);
}


/**
 * Draws a path to the canvas. Path should be a string similar to how Raphael
 * does it (it's easier tested).
 *
 * @param {object} options An object containing options: path, width and color.
 */
Canvas.prototype.drawPath = function (options) {
	const context = this._context;
	context.beginPath();

	options.path.forEach(function (point) {
		switch (point.type) {
			case 'M':
				context.moveTo(point.x, point.y);
				break;

			case 'L':
				context.lineTo(point.x, point.y);
		}
	});

	context.lineWidth = options.width;
	context.strokeStyle = options.color;
	context.lineCap = options.lineCap;
	context.stroke();
};

/**
 * Fill the entire canvas with a specified color. Good for backgrounds.
 *
 * @param {string} color The color to fill the canvas with.
 */
Canvas.prototype.fill = function (color) {
	const context = this._context;
	context.rect(0, 0, this._canvas.width, this._canvas.height);
	context.fillStyle = color;
	context.fill();
};

/**
 * Export the contents of the canvas to a specified image element.
 *
 * @param {string} selector Selector matching the element to export to.
 */
Canvas.prototype.exportTo = function (selector) {
	this._canvas.toBlob(function (blob) {
		const image = document.querySelector(selector);
		image.src = URL.createObjectURL(blob);
	});
};

module.exports = Canvas;

},{"./coord":4}],4:[function(require,module,exports){
/**
 * Stores the x and y positions of a coordinate and provides some useful helper
 * functions.
 *
 * @param {number} x The x position.
 * @param {number} y The y position.
 * @constructor
 */
function Coord(x, y) {
	if (!(this instanceof Coord)) {
		return new Coord(x, y);
	}

	this.x = x;
	this.y = y;
}

/**
 * Works out the distance between two coordinates using Pythagoras' theorum.
 *
 * @param {Coord} other The other coordinate.
 * @returns {number} The distance between the two coordinates.
 */
Coord.prototype.distFrom = function (other) {
	const distX = Math.pow(this.x - other.x, 2);
	const distY = Math.pow(this.y - other.y, 2);

	return Math.pow(distX + distY, 0.5);
};

/**
 * Adds a vector to the coordinate.
 *
 * @param {Vector} vector The vector to add to the coordinate.
 * @returns {Coord} The new coordinate.
 */
Coord.prototype.add = function (vector) {
	return new Coord(this.x + vector.ax, this.y + vector.ay);
};

module.exports = Coord;

},{}],5:[function(require,module,exports){
const Vector = require('./vector');

/**
 * Generates a slightly wobbly path between two coordinates. The amount of
 * wobbliness can be changed by tweaking the above constants.
 *
 * @param {Coord} from The coordinate to draw from.
 * @param {Coord} to The coordinate to draw to.
 * @param {object} config Configuration options.
 * @returns {Array} An array representing the path to draw.
 */
function generatePath(from, to, config) {
	let path = [
		{ type: 'M', x: from.x, y: from.y }
	];

	let currentPoint = from;
	let currentDirection;

	// Safety to avoid crashing browsers
	let maxRuns = 1000;

	do {

		// This is the perfect direction: also, a boring straight line
		let perfect = Vector.between(currentPoint, to);

		let newDirection;
		if (currentDirection) {
			// This carries on most in the direction the line is currently going, but
			// skews it a little bit back towards the point it's supposed to be going
			// so that it's not too crazy
			newDirection = Vector.average(
					perfect.restrictMagnitude(config.BIAS_TO_PERFECT),
					currentDirection.restrictMagnitude(1 - config.BIAS_TO_PERFECT)
			);
		} else {
			newDirection = perfect;
		}

		newDirection = newDirection
				.restrictMagnitude(config.SEGMENT_LENGTH)
				.randomiseByFactor(config.RANDOM_FACTOR);

		let newPoint = currentPoint.add(newDirection);

		path.push({ type: 'L', x: newPoint.x, y: newPoint.y });
		currentPoint = newPoint;
		currentDirection = newDirection;

	} while (currentPoint.distFrom(to) > config.SEGMENT_LENGTH * 10 && maxRuns--);

	return path;
}

module.exports = generatePath;

},{"./vector":7}],6:[function(require,module,exports){
/**
 * Returns a random number between -0.5 and 0.5. Basically in its own function
 * so that it can be replaced with a different random function if needed.
 *
 * @returns {number} A random number between -0.5 and 0.5.
 */
function random() {
	return Math.random() - 0.5;
}

/**
 * Generate normally distributed random numbers.
 *
 * Only an approximation: actually a Irwinâ€“Hall distribution.
 *
 * @returns {number} A number between -6 and 6 that will approximately map to a
 * normal distribution.
 */
random.normal = function () {
	var total = 0;

	for (let i = 0; i < 12; i++) {
		total += random();
	}

	return total;
};

module.exports = random;

},{}],7:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./random":6,"dup":2}],8:[function(require,module,exports){
const random = require('../lib/random');

exports.NUMBER_OF_LINES = 1000;

exports.startLength = () => 400 + random() * 500;
exports.endLength = () => 800 + random() * 100;


exports.BACKGROUND_COLOR = '#262819';

// Colors for the path
let opacity = 0.6;

// https://color.adobe.com/Passado1-color-theme-8032401/
exports.COLORS = [
	`rgba(83, 84, 115, ${opacity})`, // blue
	`rgba(214, 216, 209, ${opacity})`, // white
	`rgba(159, 145, 124, ${opacity})`, // cream
	`rgba(142, 55, 48, ${opacity})` // red
];

exports.LINE_WIDTH = 6;


// Line generation config
exports.SEGMENT_LENGTH = 10;
exports.BIAS_TO_PERFECT = 0.5;
exports.RANDOM_FACTOR = 1;

},{"../lib/random":6}],9:[function(require,module,exports){
const Canvas = require('../lib/canvas');
const Vector = require('../lib/Vector');
const generatePath = require('../lib/generatePath');
const config = require('./config');

module.exports = function (selector) {
	const canvas = new Canvas(selector);
	const origin = canvas.origin;

	canvas.fill(config.BACKGROUND_COLOR);

	for (var i = 0; i < config.NUMBER_OF_LINES; i++) {
		let randomDirection = Vector.random();
		let start = origin.add(randomDirection.restrictMagnitude(config.startLength()));
		let end = origin.add(randomDirection.restrictMagnitude(config.endLength()));

		canvas.drawPath({
			path: generatePath(start, end, config),
			width: config.LINE_WIDTH,
			color: config.COLORS[Math.floor(Math.random() * config.COLORS.length)]
		});
	}
};

},{"../lib/Vector":2,"../lib/canvas":3,"../lib/generatePath":5,"./config":8}],10:[function(require,module,exports){
exports.BACKGROUND_COLOR = '#4E4F59';
exports.COLOR = '#F28A5C';

exports.DIGITS = '3' +
	'141592653589793238462643383279502884197169399375105820974944592307816406286' +
	'208998628034825342117067982148086513282306647093844609550582231725359408128481' +
	'117450284102701938521105559644622948954930381964428810975665933446128475648233' +
	'786783165271201909145648566923460348610454326648213393607260249141273724587006' +
	'606315588174881520920962829254091715364367892590360011330530548820466521384146' +
	'951941511609433057270365759591953092186117381932611793105118548074462379962749' +
	'567351885752724891227938183011949129833673362440656643086021394946395224737190' +
	'702179860943702770539217176293176752384674818467669405132000568127145263560827' +
	'785771342757789609173637178721468440901224953430146549585371050792279689258923' +
	'542019956112129021960864034418159813629774771309960518707211349999998372978049' +
	'951059731732816096318595024459455346908302642522308253344685035261931188171010' +
	'003137838752886587533208381420617177669147303598253490428755468731159562863882' +
	'353787593751957781857780532171226806613001927876611195909216420198938095257201' +
	'065485863278865936153381827968230301952035301852968995773622599413891249721775' +
	'283479131515574857242454150695950829533116861727855889075098381754637464939319' +
	'255060400927701671139009848824012858361603563707660104710181942955596198946767' +
	'837449448255379774726847104047534646208046684259069491293313677028989152104752' +
	'162056966024058038150193511253382430035587640247496473263914199272604269922796' +
	'782354781636009341721641219924586315030286182974555706749838505494588586926995' +
	'690927210797509302955321165344987202755960236480665499119881834797753566369807' +
	'426542527862551818417574672890977772793800081647060016145249192173217214772350' +
	'141441973568548161361157352552133475741849468438523323907394143334547762416862' +
	'518983569485562099219222184272550254256887671790494601653466804988627232791786' +
	'085784383827967976681454100953883786360950680064225125205117392984896084128488' +
	'626945604241965285022210661186306744278622039194945047123713786960956364371917' +
	'287467764657573962413890865832645995813390478027590099465764078951269468398352' +
	'595709825822620522489407726719478268482601476990902640136394437455305068203496' +
	'252451749399651431429809190659250937221696461515709858387410597885959772975498' +
	'930161753928468138268683868942774155991855925245953959431049972524680845987273' +
	'644695848653836736222626099124608051243884390451244136549762780797715691435997' +
	'700129616089441694868555848406353422072225828488648158456028506016842739452267' +
	'467678895252138522549954666727823986456596116354886230577456498035593634568174' +
	'324112515076069479451096596094025228879710893145669136867228748940560101503308' +
	'617928680920874760917824938589009714909675985261365549781893129784821682998948' +
	'722658804857564014270477555132379641451523746234364542858444795265867821051141' +
	'354735739523113427166102135969536231442952484937187110145765403590279934403742' +
	'007310578539062198387447808478489683321445713868751943506430218453191048481005' +
	'370614680674919278191197939952061419663428754440643745123718192179998391015919' +
	'561814675142691239748940907186494231961567945208095146550225231603881930142093' +
	'762137855956638937787083039069792077346722182562599661501421503068038447734549' +
	'202605414665925201497442850732518666002132434088190710486331734649651453905796' +
	'268561005508106658796998163574736384052571459102897064140110971206280439039759' +
	'515677157700420337869936007230558763176359421873125147120532928191826186125867' +
	'321579198414848829164470609575270695722091756711672291098169091528017350671274' +
	'858322287183520935396572512108357915136988209144421006751033467110314126711136' +
	'990865851639831501970165151168517143765761835155650884909989859982387345528331' +
	'635507647918535893226185489632132933089857064204675259070915481416549859461637' +
	'180270981994309924488957571282890592323326097299712084433573265489382391193259' +
	'746366730583604142813883032038249037589852437441702913276561809377344403070746' +
	'921120191302033038019762110110044929321516084244485963766983895228684783123552' +
	'658213144957685726243344189303968642624341077322697802807318915441101044682325' +
	'271620105265227211166039666557309254711055785376346682065310989652691862056476' +
	'931257058635662018558100729360659876486117910453348850346113657686753249441668' +
	'039626579787718556084552965412665408530614344431858676975145661406800700237877' +
	'659134401712749470420562230538994561314071127000407854733269939081454664645880' +
	'797270826683063432858785698305235808933065757406795457163775254202114955761581' +
	'400250126228594130216471550979259230990796547376125517656751357517829666454779' +
	'174501129961489030463994713296210734043751895735961458901938971311179042978285' +
	'647503203198691514028708085990480109412147221317947647772622414254854540332157' +
	'185306142288137585043063321751829798662237172159160771669254748738986654949450' +
	'114654062843366393790039769265672146385306736096571209180763832716641627488880' +
	'078692560290228472104031721186082041900042296617119637792133757511495950156604' +
	'963186294726547364252308177036751590673502350728354056704038674351362222477158' +
	'915049530984448933309634087807693259939780541934144737744184263129860809988868' +
	'741326047215695162396586457302163159819319516735381297416772947867242292465436' +
	'680098067692823828068996400482435403701416314965897940924323789690706977942236' +
	'250822168895738379862300159377647165122893578601588161755782973523344604281512' +
	'627203734314653197777416031990665541876397929334419521541341899485444734567383' +
	'162499341913181480927777103863877343177207545654532207770921201905166096280490' +
	'926360197598828161332316663652861932668633606273567630354477628035045077723554' +
	'710585954870279081435624014517180624643626794561275318134078330336254232783944' +
	'975382437205835311477119926063813346776879695970309833913077109870408591337464' +
	'144282277263465947047458784778720192771528073176790770715721344473060570073349' +
	'243693113835049316312840425121925651798069411352801314701304781643788518529092' +
	'854520116583934196562134914341595625865865570552690496520985803385072242648293' +
	'972858478316305777756068887644624824685792603953527734803048029005876075825104' +
	'747091643961362676044925627420420832085661190625454337213153595845068772460290' +
	'161876679524061634252257719542916299193064553779914037340432875262888963995879' +
	'475729174642635745525407909145135711136941091193932519107602082520261879853188' +
	'770584297259167781314969900901921169717372784768472686084900337702424291651300' +
	'500516832336435038951702989392233451722013812806965011784408745196012122859937' +
	'162313017114448464090389064495444006198690754851602632750529834918740786680881';

},{}],11:[function(require,module,exports){
const Canvas = require('../lib/canvas');
const Vector = require('../lib/vector');
const config = require('./config');

module.exports = function (selector) {
	const canvas = new Canvas(selector);
	const origin = canvas.origin;

	document.documentElement.style.backgroundColor = config.BACKGROUND_COLOR;
	canvas.fill(config.BACKGROUND_COLOR);

	const digits = config.DIGITS.split('').map(Number);
	let i = 0;

	digits.forEach(function (digit) {
		const path = [];
		const iAfter = i + digit + 1;

		for (let j = i; j <= iAfter; j++) {
			const direction = Math.PI / 150 * j - Math.PI / 2;
			const magnitude = Math.max(1200 / Math.pow(j / 3500 + 1, 1.5) - 50, 0);

			const vector = Vector.fromDirection(direction, magnitude);
			const coord = origin.add(vector);

			path.push({ type: 'L', x: coord.x, y: coord.y });
		}

		i = iAfter + 3;

		path[0].type = 'M';

		const width = 20 - Math.pow(i / 40, 0.5);

		canvas.drawPath({
			path,
			width,
			color: config.COLOR,
			lineCap: 'round'
		});
	});
};

},{"../lib/canvas":3,"../lib/vector":7,"./config":10}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvaW5kZXguanMiLCJzcmMvbGliL1ZlY3Rvci5qcyIsInNyYy9saWIvY2FudmFzLmpzIiwic3JjL2xpYi9jb29yZC5qcyIsInNyYy9saWIvZ2VuZXJhdGVQYXRoLmpzIiwic3JjL2xpYi9yYW5kb20uanMiLCJzcmMvbm9ybWFsLWxpbmVzL2NvbmZpZy5qcyIsInNyYy9ub3JtYWwtbGluZXMvaW5kZXguanMiLCJzcmMvcGVyaW1ldHJvcy9jb25maWcuanMiLCJzcmMvcGVyaW1ldHJvcy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIndpbmRvdy5ub3JtYWxMaW5lcyA9IHJlcXVpcmUoJy4vbm9ybWFsLWxpbmVzJyk7XG53aW5kb3cucGVyaW1ldHJvcyA9IHJlcXVpcmUoJy4vcGVyaW1ldHJvcycpO1xuIiwiY29uc3QgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcblxuLyoqXG4gKiBTdG9yZXMgdGhlIHggYW5kIHkgZGltZW5zaW9ucyBvZiBhIGV1Y2xpZGVhbiB2ZWN0b3IgaW4gdGhlIGNhcnRlc2lhbiBwbGFuZVxuICogYW5kIHByb3ZpZGVzIHNvbWUgdXNlZnVsIGhlbHBlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGF4IFRoZSB4IGRpbWVuc2lvbiBvZiB0aGUgdmVjdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGF5IFRoZSB5IGRpbWVuc2lvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBWZWN0b3IoYXgsIGF5KSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBWZWN0b3IpKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWN0b3IoYXgsIGF5KTtcblx0fVxuXG5cdHRoaXMuYXggPSBheDtcblx0dGhpcy5heSA9IGF5O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yLlxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci5cbiAqL1xuVmVjdG9yLnByb3RvdHlwZS5nZXRNYWduaXR1ZGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBNYXRoLnBvdyhNYXRoLnBvdyh0aGlzLmF4LCAyKSArIE1hdGgucG93KHRoaXMuYXksIDIpLCAwLjUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IHZlY3RvciB3aXRoIGEgc3BlY2lmaWVkIG1hZ25pdHVkZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3TWFnbml0dWRlIFRoZSBtYWduaXR1ZGUgb2YgdGhlIG5ldyB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7VmVjdG9yfSBBIG5ldyB2ZWN0b3Igd2l0aCBzcGVjaWZpZWQgbWFnbml0dWRlLlxuICovXG5WZWN0b3IucHJvdG90eXBlLnJlc3RyaWN0TWFnbml0dWRlID0gZnVuY3Rpb24gKG5ld01hZ25pdHVkZSkge1xuXHRjb25zdCByYXRpbyA9IG5ld01hZ25pdHVkZSAvIHRoaXMuZ2V0TWFnbml0dWRlKCk7XG5cblx0cmV0dXJuIG5ldyBWZWN0b3IodGhpcy5heCAqIHJhdGlvLCB0aGlzLmF5ICogcmF0aW8pO1xufTtcblxuLyoqXG4gKiBDaGFuZ2VzIGEgdmVjdG9yIHNsaWdodGx5IGJ5IGEgcmFuZG9tIGFtb3VudC4gVXNlcyBhIHJhbmRvbSBmdW5jdGlvbiB3aXRoIGFcbiAqIG5vcm1hbCBkaXN0cmlidXRpb24sIHNvIGl0J3MgdXN1YWxseSBub3QgdGhhdCBkaWZmZXJlbnQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtmYWN0b3I9MV0gU3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBub3JtYWwgZGlzdHJpYnV0aW9uXG4gKiBmdW5jdGlvbiB1c2VkLlxuICogQHJldHVybnMge1ZlY3Rvcn0gU2xpZ2h0bHkgZGlmZmVyZW50IHZlY3Rvci5cbiAqL1xuVmVjdG9yLnByb3RvdHlwZS5yYW5kb21pc2VCeUZhY3RvciA9IGZ1bmN0aW9uIChmYWN0b3IgPSAxKSB7XG5cdHJldHVybiBuZXcgVmVjdG9yKHRoaXMuYXggKyByYW5kb20ubm9ybWFsKCkgKiBmYWN0b3IsIHRoaXMuYXkgKyByYW5kb20ubm9ybWFsKCkgKiBmYWN0b3IpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB2ZWN0b3IgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAqXG4gKiBAcGFyYW0ge0Nvb3JkfSBmcm9tIENvb3JkaW5hdGUgdG8gY2FsY3VsYXRlIHZlY3RvciBmcm9tXG4gKiBAcGFyYW0ge0Nvb3JkfSB0byBDb29yZGluYXRlIHRvIGNhbGN1bGF0ZSB2ZWN0b3IgdG9cbiAqL1xuVmVjdG9yLmJldHdlZW4gPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcblx0cmV0dXJuIG5ldyBWZWN0b3IodG8ueCAtIGZyb20ueCwgdG8ueSAtIGZyb20ueSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGF2ZXJhZ2Ugb2YgbiB2ZWN0b3JzLlxuICpcbiAqIEBwYXJhbSB7Li4uVmVjdG9yfSB2ZWN0b3JzIE9uZSBvciBtb3JlIHZlY3RvcnMuXG4gKiBAcmV0dXJucyB7VmVjdG9yfSBUaGUgYXZlcmFnZSB2ZWN0b3IuXG4gKi9cblZlY3Rvci5hdmVyYWdlID0gZnVuY3Rpb24gKC4uLnZlY3RvcnMpIHtcblx0Y29uc3QgYXggPSB2ZWN0b3JzLnJlZHVjZSgoc3VtLCB7IGF4IH0pID0+IHN1bSArIGF4LCAwKSAvIHZlY3RvcnMubGVuZ3RoO1xuXHRjb25zdCBheSA9IHZlY3RvcnMucmVkdWNlKChzdW0sIHsgYXkgfSkgPT4gc3VtICsgYXksIDApIC8gdmVjdG9ycy5sZW5ndGg7XG5cblx0cmV0dXJuIG5ldyBWZWN0b3IoYXgsIGF5KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciBnb2luZyA8IDAuNSBvbiB0aGUgeCBhbmQgeSBheGVzLlxuICpcbiAqIEByZXR1cm5zIHtWZWN0b3J9IFJhbmRvbSB2ZWN0b3IuXG4gKi9cblZlY3Rvci5yYW5kb20gPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgVmVjdG9yKHJhbmRvbSgpLCByYW5kb20oKSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgdmVjdG9yIGZyb20gdGhlIGRpcmVjdGlvbiBhbmQgbWFnbml0dWRlIGluc3RlYWQgb2YgZnJvbSB0aGVcbiAqIGNvbXBvbmVudHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBEaXJlY3Rpb24gaW4gcmFkaWFucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYWduaXR1ZGUgTWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7VmVjdG9yfSBHZW5lcmF0ZWQgdmVjdG9yLlxuICovXG5WZWN0b3IuZnJvbURpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIG1hZ25pdHVkZSA9IDEpIHtcblx0Y29uc3QgYXggPSBtYWduaXR1ZGUgKiBNYXRoLmNvcyhkaXJlY3Rpb24pO1xuXHRjb25zdCBheSA9IG1hZ25pdHVkZSAqIE1hdGguc2luKGRpcmVjdGlvbik7XG5cdHJldHVybiBuZXcgVmVjdG9yKGF4LCBheSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvcjtcbiIsImNvbnN0IENvb3JkID0gcmVxdWlyZSgnLi9jb29yZCcpO1xuXG4vKipcbiAqIEEgc21hbGwgd3JhcHBlciBmdW5jdGlvbiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gbWl4IGNhbnZhcyBsb2dpYyByYW5kb21seVxuICogaW4gdGhlIHJlc3Qgb2YgdGhlIGNvZGUuIEJhc2ljYWxseSBtYWtlcyBldmVyeXRoaW5nIHRlc3RhYmxlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgZWxlbWVudCB0byBkcmF3IG9udG8uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ2FudmFzKHNlbGVjdG9yKSB7XG5cdHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuXHR0aGlzLl9jb250ZXh0ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cblx0dGhpcy5vcmlnaW4gPSBuZXcgQ29vcmQodGhpcy5fY2FudmFzLndpZHRoIC8gMiwgdGhpcy5fY2FudmFzLmhlaWdodCAvIDIpO1xufVxuXG5cbi8qKlxuICogRHJhd3MgYSBwYXRoIHRvIHRoZSBjYW52YXMuIFBhdGggc2hvdWxkIGJlIGEgc3RyaW5nIHNpbWlsYXIgdG8gaG93IFJhcGhhZWxcbiAqIGRvZXMgaXQgKGl0J3MgZWFzaWVyIHRlc3RlZCkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9uczogcGF0aCwgd2lkdGggYW5kIGNvbG9yLlxuICovXG5DYW52YXMucHJvdG90eXBlLmRyYXdQYXRoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0Y29uc3QgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cdGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cblx0b3B0aW9ucy5wYXRoLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0c3dpdGNoIChwb2ludC50eXBlKSB7XG5cdFx0XHRjYXNlICdNJzpcblx0XHRcdFx0Y29udGV4dC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdMJzpcblx0XHRcdFx0Y29udGV4dC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG5cdFx0fVxuXHR9KTtcblxuXHRjb250ZXh0LmxpbmVXaWR0aCA9IG9wdGlvbnMud2lkdGg7XG5cdGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmNvbG9yO1xuXHRjb250ZXh0LmxpbmVDYXAgPSBvcHRpb25zLmxpbmVDYXA7XG5cdGNvbnRleHQuc3Ryb2tlKCk7XG59O1xuXG4vKipcbiAqIEZpbGwgdGhlIGVudGlyZSBjYW52YXMgd2l0aCBhIHNwZWNpZmllZCBjb2xvci4gR29vZCBmb3IgYmFja2dyb3VuZHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIFRoZSBjb2xvciB0byBmaWxsIHRoZSBjYW52YXMgd2l0aC5cbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKGNvbG9yKSB7XG5cdGNvbnN0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXHRjb250ZXh0LnJlY3QoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcblx0Y29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcblx0Y29udGV4dC5maWxsKCk7XG59O1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgY29udGVudHMgb2YgdGhlIGNhbnZhcyB0byBhIHNwZWNpZmllZCBpbWFnZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciBtYXRjaGluZyB0aGUgZWxlbWVudCB0byBleHBvcnQgdG8uXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuZXhwb3J0VG8gPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0dGhpcy5fY2FudmFzLnRvQmxvYihmdW5jdGlvbiAoYmxvYikge1xuXHRcdGNvbnN0IGltYWdlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cdFx0aW1hZ2Uuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhcztcbiIsIi8qKlxuICogU3RvcmVzIHRoZSB4IGFuZCB5IHBvc2l0aW9ucyBvZiBhIGNvb3JkaW5hdGUgYW5kIHByb3ZpZGVzIHNvbWUgdXNlZnVsIGhlbHBlclxuICogZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ29vcmQoeCwgeSkge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29vcmQpKSB7XG5cdFx0cmV0dXJuIG5ldyBDb29yZCh4LCB5KTtcblx0fVxuXG5cdHRoaXMueCA9IHg7XG5cdHRoaXMueSA9IHk7XG59XG5cbi8qKlxuICogV29ya3Mgb3V0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlcyB1c2luZyBQeXRoYWdvcmFzJyB0aGVvcnVtLlxuICpcbiAqIEBwYXJhbSB7Q29vcmR9IG90aGVyIFRoZSBvdGhlciBjb29yZGluYXRlLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBjb29yZGluYXRlcy5cbiAqL1xuQ29vcmQucHJvdG90eXBlLmRpc3RGcm9tID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdGNvbnN0IGRpc3RYID0gTWF0aC5wb3codGhpcy54IC0gb3RoZXIueCwgMik7XG5cdGNvbnN0IGRpc3RZID0gTWF0aC5wb3codGhpcy55IC0gb3RoZXIueSwgMik7XG5cblx0cmV0dXJuIE1hdGgucG93KGRpc3RYICsgZGlzdFksIDAuNSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSB2ZWN0b3IgdG8gdGhlIGNvb3JkaW5hdGUuXG4gKlxuICogQHBhcmFtIHtWZWN0b3J9IHZlY3RvciBUaGUgdmVjdG9yIHRvIGFkZCB0byB0aGUgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm5zIHtDb29yZH0gVGhlIG5ldyBjb29yZGluYXRlLlxuICovXG5Db29yZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZlY3Rvcikge1xuXHRyZXR1cm4gbmV3IENvb3JkKHRoaXMueCArIHZlY3Rvci5heCwgdGhpcy55ICsgdmVjdG9yLmF5KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29vcmQ7XG4iLCJjb25zdCBWZWN0b3IgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHNsaWdodGx5IHdvYmJseSBwYXRoIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzLiBUaGUgYW1vdW50IG9mXG4gKiB3b2JibGluZXNzIGNhbiBiZSBjaGFuZ2VkIGJ5IHR3ZWFraW5nIHRoZSBhYm92ZSBjb25zdGFudHMuXG4gKlxuICogQHBhcmFtIHtDb29yZH0gZnJvbSBUaGUgY29vcmRpbmF0ZSB0byBkcmF3IGZyb20uXG4gKiBAcGFyYW0ge0Nvb3JkfSB0byBUaGUgY29vcmRpbmF0ZSB0byBkcmF3IHRvLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgcGF0aCB0byBkcmF3LlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGgoZnJvbSwgdG8sIGNvbmZpZykge1xuXHRsZXQgcGF0aCA9IFtcblx0XHR7IHR5cGU6ICdNJywgeDogZnJvbS54LCB5OiBmcm9tLnkgfVxuXHRdO1xuXG5cdGxldCBjdXJyZW50UG9pbnQgPSBmcm9tO1xuXHRsZXQgY3VycmVudERpcmVjdGlvbjtcblxuXHQvLyBTYWZldHkgdG8gYXZvaWQgY3Jhc2hpbmcgYnJvd3NlcnNcblx0bGV0IG1heFJ1bnMgPSAxMDAwO1xuXG5cdGRvIHtcblxuXHRcdC8vIFRoaXMgaXMgdGhlIHBlcmZlY3QgZGlyZWN0aW9uOiBhbHNvLCBhIGJvcmluZyBzdHJhaWdodCBsaW5lXG5cdFx0bGV0IHBlcmZlY3QgPSBWZWN0b3IuYmV0d2VlbihjdXJyZW50UG9pbnQsIHRvKTtcblxuXHRcdGxldCBuZXdEaXJlY3Rpb247XG5cdFx0aWYgKGN1cnJlbnREaXJlY3Rpb24pIHtcblx0XHRcdC8vIFRoaXMgY2FycmllcyBvbiBtb3N0IGluIHRoZSBkaXJlY3Rpb24gdGhlIGxpbmUgaXMgY3VycmVudGx5IGdvaW5nLCBidXRcblx0XHRcdC8vIHNrZXdzIGl0IGEgbGl0dGxlIGJpdCBiYWNrIHRvd2FyZHMgdGhlIHBvaW50IGl0J3Mgc3VwcG9zZWQgdG8gYmUgZ29pbmdcblx0XHRcdC8vIHNvIHRoYXQgaXQncyBub3QgdG9vIGNyYXp5XG5cdFx0XHRuZXdEaXJlY3Rpb24gPSBWZWN0b3IuYXZlcmFnZShcblx0XHRcdFx0XHRwZXJmZWN0LnJlc3RyaWN0TWFnbml0dWRlKGNvbmZpZy5CSUFTX1RPX1BFUkZFQ1QpLFxuXHRcdFx0XHRcdGN1cnJlbnREaXJlY3Rpb24ucmVzdHJpY3RNYWduaXR1ZGUoMSAtIGNvbmZpZy5CSUFTX1RPX1BFUkZFQ1QpXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdEaXJlY3Rpb24gPSBwZXJmZWN0O1xuXHRcdH1cblxuXHRcdG5ld0RpcmVjdGlvbiA9IG5ld0RpcmVjdGlvblxuXHRcdFx0XHQucmVzdHJpY3RNYWduaXR1ZGUoY29uZmlnLlNFR01FTlRfTEVOR1RIKVxuXHRcdFx0XHQucmFuZG9taXNlQnlGYWN0b3IoY29uZmlnLlJBTkRPTV9GQUNUT1IpO1xuXG5cdFx0bGV0IG5ld1BvaW50ID0gY3VycmVudFBvaW50LmFkZChuZXdEaXJlY3Rpb24pO1xuXG5cdFx0cGF0aC5wdXNoKHsgdHlwZTogJ0wnLCB4OiBuZXdQb2ludC54LCB5OiBuZXdQb2ludC55IH0pO1xuXHRcdGN1cnJlbnRQb2ludCA9IG5ld1BvaW50O1xuXHRcdGN1cnJlbnREaXJlY3Rpb24gPSBuZXdEaXJlY3Rpb247XG5cblx0fSB3aGlsZSAoY3VycmVudFBvaW50LmRpc3RGcm9tKHRvKSA+IGNvbmZpZy5TRUdNRU5UX0xFTkdUSCAqIDEwICYmIG1heFJ1bnMtLSk7XG5cblx0cmV0dXJuIHBhdGg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVQYXRoO1xuIiwiLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIC0wLjUgYW5kIDAuNS4gQmFzaWNhbGx5IGluIGl0cyBvd24gZnVuY3Rpb25cbiAqIHNvIHRoYXQgaXQgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBkaWZmZXJlbnQgcmFuZG9tIGZ1bmN0aW9uIGlmIG5lZWRlZC5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAtMC41IGFuZCAwLjUuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbSgpIHtcblx0cmV0dXJuIE1hdGgucmFuZG9tKCkgLSAwLjU7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgbm9ybWFsbHkgZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlcnMuXG4gKlxuICogT25seSBhbiBhcHByb3hpbWF0aW9uOiBhY3R1YWxseSBhIElyd2lu4oCTSGFsbCBkaXN0cmlidXRpb24uXG4gKlxuICogQHJldHVybnMge251bWJlcn0gQSBudW1iZXIgYmV0d2VlbiAtNiBhbmQgNiB0aGF0IHdpbGwgYXBwcm94aW1hdGVseSBtYXAgdG8gYVxuICogbm9ybWFsIGRpc3RyaWJ1dGlvbi5cbiAqL1xucmFuZG9tLm5vcm1hbCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHRvdGFsID0gMDtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcblx0XHR0b3RhbCArPSByYW5kb20oKTtcblx0fVxuXG5cdHJldHVybiB0b3RhbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcmFuZG9tO1xuIiwiY29uc3QgcmFuZG9tID0gcmVxdWlyZSgnLi4vbGliL3JhbmRvbScpO1xuXG5leHBvcnRzLk5VTUJFUl9PRl9MSU5FUyA9IDEwMDA7XG5cbmV4cG9ydHMuc3RhcnRMZW5ndGggPSAoKSA9PiA0MDAgKyByYW5kb20oKSAqIDUwMDtcbmV4cG9ydHMuZW5kTGVuZ3RoID0gKCkgPT4gODAwICsgcmFuZG9tKCkgKiAxMDA7XG5cblxuZXhwb3J0cy5CQUNLR1JPVU5EX0NPTE9SID0gJyMyNjI4MTknO1xuXG4vLyBDb2xvcnMgZm9yIHRoZSBwYXRoXG5sZXQgb3BhY2l0eSA9IDAuNjtcblxuLy8gaHR0cHM6Ly9jb2xvci5hZG9iZS5jb20vUGFzc2FkbzEtY29sb3ItdGhlbWUtODAzMjQwMS9cbmV4cG9ydHMuQ09MT1JTID0gW1xuXHRgcmdiYSg4MywgODQsIDExNSwgJHtvcGFjaXR5fSlgLCAvLyBibHVlXG5cdGByZ2JhKDIxNCwgMjE2LCAyMDksICR7b3BhY2l0eX0pYCwgLy8gd2hpdGVcblx0YHJnYmEoMTU5LCAxNDUsIDEyNCwgJHtvcGFjaXR5fSlgLCAvLyBjcmVhbVxuXHRgcmdiYSgxNDIsIDU1LCA0OCwgJHtvcGFjaXR5fSlgIC8vIHJlZFxuXTtcblxuZXhwb3J0cy5MSU5FX1dJRFRIID0gNjtcblxuXG4vLyBMaW5lIGdlbmVyYXRpb24gY29uZmlnXG5leHBvcnRzLlNFR01FTlRfTEVOR1RIID0gMTA7XG5leHBvcnRzLkJJQVNfVE9fUEVSRkVDVCA9IDAuNTtcbmV4cG9ydHMuUkFORE9NX0ZBQ1RPUiA9IDE7XG4iLCJjb25zdCBDYW52YXMgPSByZXF1aXJlKCcuLi9saWIvY2FudmFzJyk7XG5jb25zdCBWZWN0b3IgPSByZXF1aXJlKCcuLi9saWIvVmVjdG9yJyk7XG5jb25zdCBnZW5lcmF0ZVBhdGggPSByZXF1aXJlKCcuLi9saWIvZ2VuZXJhdGVQYXRoJyk7XG5jb25zdCBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuXHRjb25zdCBjYW52YXMgPSBuZXcgQ2FudmFzKHNlbGVjdG9yKTtcblx0Y29uc3Qgb3JpZ2luID0gY2FudmFzLm9yaWdpbjtcblxuXHRjYW52YXMuZmlsbChjb25maWcuQkFDS0dST1VORF9DT0xPUik7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb25maWcuTlVNQkVSX09GX0xJTkVTOyBpKyspIHtcblx0XHRsZXQgcmFuZG9tRGlyZWN0aW9uID0gVmVjdG9yLnJhbmRvbSgpO1xuXHRcdGxldCBzdGFydCA9IG9yaWdpbi5hZGQocmFuZG9tRGlyZWN0aW9uLnJlc3RyaWN0TWFnbml0dWRlKGNvbmZpZy5zdGFydExlbmd0aCgpKSk7XG5cdFx0bGV0IGVuZCA9IG9yaWdpbi5hZGQocmFuZG9tRGlyZWN0aW9uLnJlc3RyaWN0TWFnbml0dWRlKGNvbmZpZy5lbmRMZW5ndGgoKSkpO1xuXG5cdFx0Y2FudmFzLmRyYXdQYXRoKHtcblx0XHRcdHBhdGg6IGdlbmVyYXRlUGF0aChzdGFydCwgZW5kLCBjb25maWcpLFxuXHRcdFx0d2lkdGg6IGNvbmZpZy5MSU5FX1dJRFRILFxuXHRcdFx0Y29sb3I6IGNvbmZpZy5DT0xPUlNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY29uZmlnLkNPTE9SUy5sZW5ndGgpXVxuXHRcdH0pO1xuXHR9XG59O1xuIiwiZXhwb3J0cy5CQUNLR1JPVU5EX0NPTE9SID0gJyM0RTRGNTknO1xuZXhwb3J0cy5DT0xPUiA9ICcjRjI4QTVDJztcblxuZXhwb3J0cy5ESUdJVFMgPSAnMycgK1xuXHQnMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTAyODg0MTk3MTY5Mzk5Mzc1MTA1ODIwOTc0OTQ0NTkyMzA3ODE2NDA2Mjg2JyArXG5cdCcyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0ODEnICtcblx0JzExNzQ1MDI4NDEwMjcwMTkzODUyMTEwNTU1OTY0NDYyMjk0ODk1NDkzMDM4MTk2NDQyODgxMDk3NTY2NTkzMzQ0NjEyODQ3NTY0ODIzMycgK1xuXHQnNzg2NzgzMTY1MjcxMjAxOTA5MTQ1NjQ4NTY2OTIzNDYwMzQ4NjEwNDU0MzI2NjQ4MjEzMzkzNjA3MjYwMjQ5MTQxMjczNzI0NTg3MDA2JyArXG5cdCc2MDYzMTU1ODgxNzQ4ODE1MjA5MjA5NjI4MjkyNTQwOTE3MTUzNjQzNjc4OTI1OTAzNjAwMTEzMzA1MzA1NDg4MjA0NjY1MjEzODQxNDYnICtcblx0Jzk1MTk0MTUxMTYwOTQzMzA1NzI3MDM2NTc1OTU5MTk1MzA5MjE4NjExNzM4MTkzMjYxMTc5MzEwNTExODU0ODA3NDQ2MjM3OTk2Mjc0OScgK1xuXHQnNTY3MzUxODg1NzUyNzI0ODkxMjI3OTM4MTgzMDExOTQ5MTI5ODMzNjczMzYyNDQwNjU2NjQzMDg2MDIxMzk0OTQ2Mzk1MjI0NzM3MTkwJyArXG5cdCc3MDIxNzk4NjA5NDM3MDI3NzA1MzkyMTcxNzYyOTMxNzY3NTIzODQ2NzQ4MTg0Njc2Njk0MDUxMzIwMDA1NjgxMjcxNDUyNjM1NjA4MjcnICtcblx0Jzc4NTc3MTM0Mjc1Nzc4OTYwOTE3MzYzNzE3ODcyMTQ2ODQ0MDkwMTIyNDk1MzQzMDE0NjU0OTU4NTM3MTA1MDc5MjI3OTY4OTI1ODkyMycgK1xuXHQnNTQyMDE5OTU2MTEyMTI5MDIxOTYwODY0MDM0NDE4MTU5ODEzNjI5Nzc0NzcxMzA5OTYwNTE4NzA3MjExMzQ5OTk5OTk4MzcyOTc4MDQ5JyArXG5cdCc5NTEwNTk3MzE3MzI4MTYwOTYzMTg1OTUwMjQ0NTk0NTUzNDY5MDgzMDI2NDI1MjIzMDgyNTMzNDQ2ODUwMzUyNjE5MzExODgxNzEwMTAnICtcblx0JzAwMzEzNzgzODc1Mjg4NjU4NzUzMzIwODM4MTQyMDYxNzE3NzY2OTE0NzMwMzU5ODI1MzQ5MDQyODc1NTQ2ODczMTE1OTU2Mjg2Mzg4MicgK1xuXHQnMzUzNzg3NTkzNzUxOTU3NzgxODU3NzgwNTMyMTcxMjI2ODA2NjEzMDAxOTI3ODc2NjExMTk1OTA5MjE2NDIwMTk4OTM4MDk1MjU3MjAxJyArXG5cdCcwNjU0ODU4NjMyNzg4NjU5MzYxNTMzODE4Mjc5NjgyMzAzMDE5NTIwMzUzMDE4NTI5Njg5OTU3NzM2MjI1OTk0MTM4OTEyNDk3MjE3NzUnICtcblx0JzI4MzQ3OTEzMTUxNTU3NDg1NzI0MjQ1NDE1MDY5NTk1MDgyOTUzMzExNjg2MTcyNzg1NTg4OTA3NTA5ODM4MTc1NDYzNzQ2NDkzOTMxOScgK1xuXHQnMjU1MDYwNDAwOTI3NzAxNjcxMTM5MDA5ODQ4ODI0MDEyODU4MzYxNjAzNTYzNzA3NjYwMTA0NzEwMTgxOTQyOTU1NTk2MTk4OTQ2NzY3JyArXG5cdCc4Mzc0NDk0NDgyNTUzNzk3NzQ3MjY4NDcxMDQwNDc1MzQ2NDYyMDgwNDY2ODQyNTkwNjk0OTEyOTMzMTM2NzcwMjg5ODkxNTIxMDQ3NTInICtcblx0JzE2MjA1Njk2NjAyNDA1ODAzODE1MDE5MzUxMTI1MzM4MjQzMDAzNTU4NzY0MDI0NzQ5NjQ3MzI2MzkxNDE5OTI3MjYwNDI2OTkyMjc5NicgK1xuXHQnNzgyMzU0NzgxNjM2MDA5MzQxNzIxNjQxMjE5OTI0NTg2MzE1MDMwMjg2MTgyOTc0NTU1NzA2NzQ5ODM4NTA1NDk0NTg4NTg2OTI2OTk1JyArXG5cdCc2OTA5MjcyMTA3OTc1MDkzMDI5NTUzMjExNjUzNDQ5ODcyMDI3NTU5NjAyMzY0ODA2NjU0OTkxMTk4ODE4MzQ3OTc3NTM1NjYzNjk4MDcnICtcblx0JzQyNjU0MjUyNzg2MjU1MTgxODQxNzU3NDY3Mjg5MDk3Nzc3Mjc5MzgwMDA4MTY0NzA2MDAxNjE0NTI0OTE5MjE3MzIxNzIxNDc3MjM1MCcgK1xuXHQnMTQxNDQxOTczNTY4NTQ4MTYxMzYxMTU3MzUyNTUyMTMzNDc1NzQxODQ5NDY4NDM4NTIzMzIzOTA3Mzk0MTQzMzM0NTQ3NzYyNDE2ODYyJyArXG5cdCc1MTg5ODM1Njk0ODU1NjIwOTkyMTkyMjIxODQyNzI1NTAyNTQyNTY4ODc2NzE3OTA0OTQ2MDE2NTM0NjY4MDQ5ODg2MjcyMzI3OTE3ODYnICtcblx0JzA4NTc4NDM4MzgyNzk2Nzk3NjY4MTQ1NDEwMDk1Mzg4Mzc4NjM2MDk1MDY4MDA2NDIyNTEyNTIwNTExNzM5Mjk4NDg5NjA4NDEyODQ4OCcgK1xuXHQnNjI2OTQ1NjA0MjQxOTY1Mjg1MDIyMjEwNjYxMTg2MzA2NzQ0Mjc4NjIyMDM5MTk0OTQ1MDQ3MTIzNzEzNzg2OTYwOTU2MzY0MzcxOTE3JyArXG5cdCcyODc0Njc3NjQ2NTc1NzM5NjI0MTM4OTA4NjU4MzI2NDU5OTU4MTMzOTA0NzgwMjc1OTAwOTk0NjU3NjQwNzg5NTEyNjk0NjgzOTgzNTInICtcblx0JzU5NTcwOTgyNTgyMjYyMDUyMjQ4OTQwNzcyNjcxOTQ3ODI2ODQ4MjYwMTQ3Njk5MDkwMjY0MDEzNjM5NDQzNzQ1NTMwNTA2ODIwMzQ5NicgK1xuXHQnMjUyNDUxNzQ5Mzk5NjUxNDMxNDI5ODA5MTkwNjU5MjUwOTM3MjIxNjk2NDYxNTE1NzA5ODU4Mzg3NDEwNTk3ODg1OTU5NzcyOTc1NDk4JyArXG5cdCc5MzAxNjE3NTM5Mjg0NjgxMzgyNjg2ODM4Njg5NDI3NzQxNTU5OTE4NTU5MjUyNDU5NTM5NTk0MzEwNDk5NzI1MjQ2ODA4NDU5ODcyNzMnICtcblx0JzY0NDY5NTg0ODY1MzgzNjczNjIyMjYyNjA5OTEyNDYwODA1MTI0Mzg4NDM5MDQ1MTI0NDEzNjU0OTc2Mjc4MDc5NzcxNTY5MTQzNTk5NycgK1xuXHQnNzAwMTI5NjE2MDg5NDQxNjk0ODY4NTU1ODQ4NDA2MzUzNDIyMDcyMjI1ODI4NDg4NjQ4MTU4NDU2MDI4NTA2MDE2ODQyNzM5NDUyMjY3JyArXG5cdCc0Njc2Nzg4OTUyNTIxMzg1MjI1NDk5NTQ2NjY3Mjc4MjM5ODY0NTY1OTYxMTYzNTQ4ODYyMzA1Nzc0NTY0OTgwMzU1OTM2MzQ1NjgxNzQnICtcblx0JzMyNDExMjUxNTA3NjA2OTQ3OTQ1MTA5NjU5NjA5NDAyNTIyODg3OTcxMDg5MzE0NTY2OTEzNjg2NzIyODc0ODk0MDU2MDEwMTUwMzMwOCcgK1xuXHQnNjE3OTI4NjgwOTIwODc0NzYwOTE3ODI0OTM4NTg5MDA5NzE0OTA5Njc1OTg1MjYxMzY1NTQ5NzgxODkzMTI5Nzg0ODIxNjgyOTk4OTQ4JyArXG5cdCc3MjI2NTg4MDQ4NTc1NjQwMTQyNzA0Nzc1NTUxMzIzNzk2NDE0NTE1MjM3NDYyMzQzNjQ1NDI4NTg0NDQ3OTUyNjU4Njc4MjEwNTExNDEnICtcblx0JzM1NDczNTczOTUyMzExMzQyNzE2NjEwMjEzNTk2OTUzNjIzMTQ0Mjk1MjQ4NDkzNzE4NzExMDE0NTc2NTQwMzU5MDI3OTkzNDQwMzc0MicgK1xuXHQnMDA3MzEwNTc4NTM5MDYyMTk4Mzg3NDQ3ODA4NDc4NDg5NjgzMzIxNDQ1NzEzODY4NzUxOTQzNTA2NDMwMjE4NDUzMTkxMDQ4NDgxMDA1JyArXG5cdCczNzA2MTQ2ODA2NzQ5MTkyNzgxOTExOTc5Mzk5NTIwNjE0MTk2NjM0Mjg3NTQ0NDA2NDM3NDUxMjM3MTgxOTIxNzk5OTgzOTEwMTU5MTknICtcblx0JzU2MTgxNDY3NTE0MjY5MTIzOTc0ODk0MDkwNzE4NjQ5NDIzMTk2MTU2Nzk0NTIwODA5NTE0NjU1MDIyNTIzMTYwMzg4MTkzMDE0MjA5MycgK1xuXHQnNzYyMTM3ODU1OTU2NjM4OTM3Nzg3MDgzMDM5MDY5NzkyMDc3MzQ2NzIyMTgyNTYyNTk5NjYxNTAxNDIxNTAzMDY4MDM4NDQ3NzM0NTQ5JyArXG5cdCcyMDI2MDU0MTQ2NjU5MjUyMDE0OTc0NDI4NTA3MzI1MTg2NjYwMDIxMzI0MzQwODgxOTA3MTA0ODYzMzE3MzQ2NDk2NTE0NTM5MDU3OTYnICtcblx0JzI2ODU2MTAwNTUwODEwNjY1ODc5Njk5ODE2MzU3NDczNjM4NDA1MjU3MTQ1OTEwMjg5NzA2NDE0MDExMDk3MTIwNjI4MDQzOTAzOTc1OScgK1xuXHQnNTE1Njc3MTU3NzAwNDIwMzM3ODY5OTM2MDA3MjMwNTU4NzYzMTc2MzU5NDIxODczMTI1MTQ3MTIwNTMyOTI4MTkxODI2MTg2MTI1ODY3JyArXG5cdCczMjE1NzkxOTg0MTQ4NDg4MjkxNjQ0NzA2MDk1NzUyNzA2OTU3MjIwOTE3NTY3MTE2NzIyOTEwOTgxNjkwOTE1MjgwMTczNTA2NzEyNzQnICtcblx0Jzg1ODMyMjI4NzE4MzUyMDkzNTM5NjU3MjUxMjEwODM1NzkxNTEzNjk4ODIwOTE0NDQyMTAwNjc1MTAzMzQ2NzExMDMxNDEyNjcxMTEzNicgK1xuXHQnOTkwODY1ODUxNjM5ODMxNTAxOTcwMTY1MTUxMTY4NTE3MTQzNzY1NzYxODM1MTU1NjUwODg0OTA5OTg5ODU5OTgyMzg3MzQ1NTI4MzMxJyArXG5cdCc2MzU1MDc2NDc5MTg1MzU4OTMyMjYxODU0ODk2MzIxMzI5MzMwODk4NTcwNjQyMDQ2NzUyNTkwNzA5MTU0ODE0MTY1NDk4NTk0NjE2MzcnICtcblx0JzE4MDI3MDk4MTk5NDMwOTkyNDQ4ODk1NzU3MTI4Mjg5MDU5MjMyMzMyNjA5NzI5OTcxMjA4NDQzMzU3MzI2NTQ4OTM4MjM5MTE5MzI1OScgK1xuXHQnNzQ2MzY2NzMwNTgzNjA0MTQyODEzODgzMDMyMDM4MjQ5MDM3NTg5ODUyNDM3NDQxNzAyOTEzMjc2NTYxODA5Mzc3MzQ0NDAzMDcwNzQ2JyArXG5cdCc5MjExMjAxOTEzMDIwMzMwMzgwMTk3NjIxMTAxMTAwNDQ5MjkzMjE1MTYwODQyNDQ0ODU5NjM3NjY5ODM4OTUyMjg2ODQ3ODMxMjM1NTInICtcblx0JzY1ODIxMzE0NDk1NzY4NTcyNjI0MzM0NDE4OTMwMzk2ODY0MjYyNDM0MTA3NzMyMjY5NzgwMjgwNzMxODkxNTQ0MTEwMTA0NDY4MjMyNScgK1xuXHQnMjcxNjIwMTA1MjY1MjI3MjExMTY2MDM5NjY2NTU3MzA5MjU0NzExMDU1Nzg1Mzc2MzQ2NjgyMDY1MzEwOTg5NjUyNjkxODYyMDU2NDc2JyArXG5cdCc5MzEyNTcwNTg2MzU2NjIwMTg1NTgxMDA3MjkzNjA2NTk4NzY0ODYxMTc5MTA0NTMzNDg4NTAzNDYxMTM2NTc2ODY3NTMyNDk0NDE2NjgnICtcblx0JzAzOTYyNjU3OTc4NzcxODU1NjA4NDU1Mjk2NTQxMjY2NTQwODUzMDYxNDM0NDQzMTg1ODY3Njk3NTE0NTY2MTQwNjgwMDcwMDIzNzg3NycgK1xuXHQnNjU5MTM0NDAxNzEyNzQ5NDcwNDIwNTYyMjMwNTM4OTk0NTYxMzE0MDcxMTI3MDAwNDA3ODU0NzMzMjY5OTM5MDgxNDU0NjY0NjQ1ODgwJyArXG5cdCc3OTcyNzA4MjY2ODMwNjM0MzI4NTg3ODU2OTgzMDUyMzU4MDg5MzMwNjU3NTc0MDY3OTU0NTcxNjM3NzUyNTQyMDIxMTQ5NTU3NjE1ODEnICtcblx0JzQwMDI1MDEyNjIyODU5NDEzMDIxNjQ3MTU1MDk3OTI1OTIzMDk5MDc5NjU0NzM3NjEyNTUxNzY1Njc1MTM1NzUxNzgyOTY2NjQ1NDc3OScgK1xuXHQnMTc0NTAxMTI5OTYxNDg5MDMwNDYzOTk0NzEzMjk2MjEwNzM0MDQzNzUxODk1NzM1OTYxNDU4OTAxOTM4OTcxMzExMTc5MDQyOTc4Mjg1JyArXG5cdCc2NDc1MDMyMDMxOTg2OTE1MTQwMjg3MDgwODU5OTA0ODAxMDk0MTIxNDcyMjEzMTc5NDc2NDc3NzI2MjI0MTQyNTQ4NTQ1NDAzMzIxNTcnICtcblx0JzE4NTMwNjE0MjI4ODEzNzU4NTA0MzA2MzMyMTc1MTgyOTc5ODY2MjIzNzE3MjE1OTE2MDc3MTY2OTI1NDc0ODczODk4NjY1NDk0OTQ1MCcgK1xuXHQnMTE0NjU0MDYyODQzMzY2MzkzNzkwMDM5NzY5MjY1NjcyMTQ2Mzg1MzA2NzM2MDk2NTcxMjA5MTgwNzYzODMyNzE2NjQxNjI3NDg4ODgwJyArXG5cdCcwNzg2OTI1NjAyOTAyMjg0NzIxMDQwMzE3MjExODYwODIwNDE5MDAwNDIyOTY2MTcxMTk2Mzc3OTIxMzM3NTc1MTE0OTU5NTAxNTY2MDQnICtcblx0Jzk2MzE4NjI5NDcyNjU0NzM2NDI1MjMwODE3NzAzNjc1MTU5MDY3MzUwMjM1MDcyODM1NDA1NjcwNDAzODY3NDM1MTM2MjIyMjQ3NzE1OCcgK1xuXHQnOTE1MDQ5NTMwOTg0NDQ4OTMzMzA5NjM0MDg3ODA3NjkzMjU5OTM5NzgwNTQxOTM0MTQ0NzM3NzQ0MTg0MjYzMTI5ODYwODA5OTg4ODY4JyArXG5cdCc3NDEzMjYwNDcyMTU2OTUxNjIzOTY1ODY0NTczMDIxNjMxNTk4MTkzMTk1MTY3MzUzODEyOTc0MTY3NzI5NDc4NjcyNDIyOTI0NjU0MzYnICtcblx0JzY4MDA5ODA2NzY5MjgyMzgyODA2ODk5NjQwMDQ4MjQzNTQwMzcwMTQxNjMxNDk2NTg5Nzk0MDkyNDMyMzc4OTY5MDcwNjk3Nzk0MjIzNicgK1xuXHQnMjUwODIyMTY4ODk1NzM4Mzc5ODYyMzAwMTU5Mzc3NjQ3MTY1MTIyODkzNTc4NjAxNTg4MTYxNzU1NzgyOTczNTIzMzQ0NjA0MjgxNTEyJyArXG5cdCc2MjcyMDM3MzQzMTQ2NTMxOTc3Nzc0MTYwMzE5OTA2NjU1NDE4NzYzOTc5MjkzMzQ0MTk1MjE1NDEzNDE4OTk0ODU0NDQ3MzQ1NjczODMnICtcblx0JzE2MjQ5OTM0MTkxMzE4MTQ4MDkyNzc3NzEwMzg2Mzg3NzM0MzE3NzIwNzU0NTY1NDUzMjIwNzc3MDkyMTIwMTkwNTE2NjA5NjI4MDQ5MCcgK1xuXHQnOTI2MzYwMTk3NTk4ODI4MTYxMzMyMzE2NjYzNjUyODYxOTMyNjY4NjMzNjA2MjczNTY3NjMwMzU0NDc3NjI4MDM1MDQ1MDc3NzIzNTU0JyArXG5cdCc3MTA1ODU5NTQ4NzAyNzkwODE0MzU2MjQwMTQ1MTcxODA2MjQ2NDM2MjY3OTQ1NjEyNzUzMTgxMzQwNzgzMzAzMzYyNTQyMzI3ODM5NDQnICtcblx0Jzk3NTM4MjQzNzIwNTgzNTMxMTQ3NzExOTkyNjA2MzgxMzM0Njc3Njg3OTY5NTk3MDMwOTgzMzkxMzA3NzEwOTg3MDQwODU5MTMzNzQ2NCcgK1xuXHQnMTQ0MjgyMjc3MjYzNDY1OTQ3MDQ3NDU4Nzg0Nzc4NzIwMTkyNzcxNTI4MDczMTc2NzkwNzcwNzE1NzIxMzQ0NDczMDYwNTcwMDczMzQ5JyArXG5cdCcyNDM2OTMxMTM4MzUwNDkzMTYzMTI4NDA0MjUxMjE5MjU2NTE3OTgwNjk0MTEzNTI4MDEzMTQ3MDEzMDQ3ODE2NDM3ODg1MTg1MjkwOTInICtcblx0Jzg1NDUyMDExNjU4MzkzNDE5NjU2MjEzNDkxNDM0MTU5NTYyNTg2NTg2NTU3MDU1MjY5MDQ5NjUyMDk4NTgwMzM4NTA3MjI0MjY0ODI5MycgK1xuXHQnOTcyODU4NDc4MzE2MzA1Nzc3NzU2MDY4ODg3NjQ0NjI0ODI0Njg1NzkyNjAzOTUzNTI3NzM0ODAzMDQ4MDI5MDA1ODc2MDc1ODI1MTA0JyArXG5cdCc3NDcwOTE2NDM5NjEzNjI2NzYwNDQ5MjU2Mjc0MjA0MjA4MzIwODU2NjExOTA2MjU0NTQzMzcyMTMxNTM1OTU4NDUwNjg3NzI0NjAyOTAnICtcblx0JzE2MTg3NjY3OTUyNDA2MTYzNDI1MjI1NzcxOTU0MjkxNjI5OTE5MzA2NDU1Mzc3OTkxNDAzNzM0MDQzMjg3NTI2Mjg4ODk2Mzk5NTg3OScgK1xuXHQnNDc1NzI5MTc0NjQyNjM1NzQ1NTI1NDA3OTA5MTQ1MTM1NzExMTM2OTQxMDkxMTkzOTMyNTE5MTA3NjAyMDgyNTIwMjYxODc5ODUzMTg4JyArXG5cdCc3NzA1ODQyOTcyNTkxNjc3ODEzMTQ5Njk5MDA5MDE5MjExNjk3MTczNzI3ODQ3Njg0NzI2ODYwODQ5MDAzMzc3MDI0MjQyOTE2NTEzMDAnICtcblx0JzUwMDUxNjgzMjMzNjQzNTAzODk1MTcwMjk4OTM5MjIzMzQ1MTcyMjAxMzgxMjgwNjk2NTAxMTc4NDQwODc0NTE5NjAxMjEyMjg1OTkzNycgK1xuXHQnMTYyMzEzMDE3MTE0NDQ4NDY0MDkwMzg5MDY0NDk1NDQ0MDA2MTk4NjkwNzU0ODUxNjAyNjMyNzUwNTI5ODM0OTE4NzQwNzg2NjgwODgxJztcbiIsImNvbnN0IENhbnZhcyA9IHJlcXVpcmUoJy4uL2xpYi9jYW52YXMnKTtcbmNvbnN0IFZlY3RvciA9IHJlcXVpcmUoJy4uL2xpYi92ZWN0b3InKTtcbmNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdGNvbnN0IGNhbnZhcyA9IG5ldyBDYW52YXMoc2VsZWN0b3IpO1xuXHRjb25zdCBvcmlnaW4gPSBjYW52YXMub3JpZ2luO1xuXG5cdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb25maWcuQkFDS0dST1VORF9DT0xPUjtcblx0Y2FudmFzLmZpbGwoY29uZmlnLkJBQ0tHUk9VTkRfQ09MT1IpO1xuXG5cdGNvbnN0IGRpZ2l0cyA9IGNvbmZpZy5ESUdJVFMuc3BsaXQoJycpLm1hcChOdW1iZXIpO1xuXHRsZXQgaSA9IDA7XG5cblx0ZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGRpZ2l0KSB7XG5cdFx0Y29uc3QgcGF0aCA9IFtdO1xuXHRcdGNvbnN0IGlBZnRlciA9IGkgKyBkaWdpdCArIDE7XG5cblx0XHRmb3IgKGxldCBqID0gaTsgaiA8PSBpQWZ0ZXI7IGorKykge1xuXHRcdFx0Y29uc3QgZGlyZWN0aW9uID0gTWF0aC5QSSAvIDE1MCAqIGogLSBNYXRoLlBJIC8gMjtcblx0XHRcdGNvbnN0IG1hZ25pdHVkZSA9IE1hdGgubWF4KDEyMDAgLyBNYXRoLnBvdyhqIC8gMzUwMCArIDEsIDEuNSkgLSA1MCwgMCk7XG5cblx0XHRcdGNvbnN0IHZlY3RvciA9IFZlY3Rvci5mcm9tRGlyZWN0aW9uKGRpcmVjdGlvbiwgbWFnbml0dWRlKTtcblx0XHRcdGNvbnN0IGNvb3JkID0gb3JpZ2luLmFkZCh2ZWN0b3IpO1xuXG5cdFx0XHRwYXRoLnB1c2goeyB0eXBlOiAnTCcsIHg6IGNvb3JkLngsIHk6IGNvb3JkLnkgfSk7XG5cdFx0fVxuXG5cdFx0aSA9IGlBZnRlciArIDM7XG5cblx0XHRwYXRoWzBdLnR5cGUgPSAnTSc7XG5cblx0XHRjb25zdCB3aWR0aCA9IDIwIC0gTWF0aC5wb3coaSAvIDQwLCAwLjUpO1xuXG5cdFx0Y2FudmFzLmRyYXdQYXRoKHtcblx0XHRcdHBhdGgsXG5cdFx0XHR3aWR0aCxcblx0XHRcdGNvbG9yOiBjb25maWcuQ09MT1IsXG5cdFx0XHRsaW5lQ2FwOiAncm91bmQnXG5cdFx0fSk7XG5cdH0pO1xufTtcbiJdfQ==
