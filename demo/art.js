(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
window.normalLines = require('./normal-lines');
window.perimetros = require('./perimetros');

},{"./normal-lines":9,"./perimetros":11}],2:[function(require,module,exports){
const random = require('./random');

/**
 * Stores the x and y dimensions of a euclidean vector in the cartesian plane
 * and provides some useful helper functions.
 *
 * @param {number} ax The x dimension of the vector.
 * @param {number} ay The y dimension.
 * @constructor
 */
function Vector(ax, ay) {
	if (!(this instanceof Vector)) {
		return new Vector(ax, ay);
	}

	this.ax = ax;
	this.ay = ay;
}

/**
 * Calculates the magnitude of the vector.
 *
 * @returns {number} The magnitude of the vector.
 */
Vector.prototype.getMagnitude = function () {
	return Math.pow(Math.pow(this.ax, 2) + Math.pow(this.ay, 2), 0.5);
};

/**
 * Returns a new vector with a specified magnitude.
 *
 * @param {number} newMagnitude The magnitude of the new vector.
 * @returns {Vector} A new vector with specified magnitude.
 */
Vector.prototype.restrictMagnitude = function (newMagnitude) {
	const ratio = newMagnitude / this.getMagnitude();

	return new Vector(this.ax * ratio, this.ay * ratio);
};

/**
 * Changes a vector slightly by a random amount. Uses a random function with a
 * normal distribution, so it's usually not that different.
 *
 * @param {number} [factor=1] Standard deviation of the normal distribution
 * function used.
 * @returns {Vector} Slightly different vector.
 */
Vector.prototype.randomiseByFactor = function (factor = 1) {
	return new Vector(this.ax + random.normal() * factor, this.ay + random.normal() * factor);
};

/**
 * Calculates the vector between two coordinates
 *
 * @param {Coord} from Coordinate to calculate vector from
 * @param {Coord} to Coordinate to calculate vector to
 */
Vector.between = function (from, to) {
	return new Vector(to.x - from.x, to.y - from.y);
};

/**
 * Returns the average of n vectors.
 *
 * @param {...Vector} vectors One or more vectors.
 * @returns {Vector} The average vector.
 */
Vector.average = function (...vectors) {
	const ax = vectors.reduce((sum, { ax }) => sum + ax, 0) / vectors.length;
	const ay = vectors.reduce((sum, { ay }) => sum + ay, 0) / vectors.length;

	return new Vector(ax, ay);
};

/**
 * Generates a random vector going < 0.5 on the x and y axes.
 *
 * @returns {Vector} Random vector.
 */
Vector.random = function () {
	return new Vector(random(), random());
};

/**
 * Generate a vector from the direction and magnitude instead of from the
 * components.
 *
 * @param {number} direction Direction in radians.
 * @param {number} magnitude Magnitude of the vector.
 * @returns {Vector} Generated vector.
 */
Vector.fromDirection = function (direction, magnitude = 1) {
	const ax = magnitude * Math.cos(direction);
	const ay = magnitude * Math.sin(direction);
	return new Vector(ax, ay);
};

module.exports = Vector;

},{"./random":6}],3:[function(require,module,exports){
const Coord = require('./coord');

/**
 * A small wrapper function so that we don't have to mix canvas logic randomly
 * in the rest of the code. Basically makes everything testable.
 *
 * @param {string} selector The element to draw onto.
 * @constructor
 */
function Canvas(selector) {
	this._canvas = document.querySelector(selector);
	this._context = this._canvas.getContext('2d');

	this.origin = new Coord(this._canvas.width / 2, this._canvas.height / 2);
}


/**
 * Draws a path to the canvas. Path should be a string similar to how Raphael
 * does it (it's easier tested).
 *
 * @param {object} options An object containing options: path, width and color.
 */
Canvas.prototype.drawPath = function (options) {
	const context = this._context;
	context.beginPath();

	options.path.forEach(function (point) {
		switch (point.type) {
			case 'M':
				context.moveTo(point.x, point.y);
				break;

			case 'L':
				context.lineTo(point.x, point.y);
		}
	});

	context.lineWidth = options.width;
	context.strokeStyle = options.color;
	context.lineCap = options.lineCap;
	context.stroke();
};

/**
 * Fill the entire canvas with a specified color. Good for backgrounds.
 *
 * @param {string} color The color to fill the canvas with.
 */
Canvas.prototype.fill = function (color) {
	const context = this._context;
	context.rect(0, 0, this._canvas.width, this._canvas.height);
	context.fillStyle = color;
	context.fill();
};

/**
 * Export the contents of the canvas to a specified image element.
 *
 * @param {string} selector Selector matching the element to export to.
 */
Canvas.prototype.exportTo = function (selector) {
	this._canvas.toBlob(function (blob) {
		const image = document.querySelector(selector);
		image.src = URL.createObjectURL(blob);
	});
};

module.exports = Canvas;

},{"./coord":4}],4:[function(require,module,exports){
/**
 * Stores the x and y positions of a coordinate and provides some useful helper
 * functions.
 *
 * @param {number} x The x position.
 * @param {number} y The y position.
 * @constructor
 */
function Coord(x, y) {
	if (!(this instanceof Coord)) {
		return new Coord(x, y);
	}

	this.x = x;
	this.y = y;
}

/**
 * Works out the distance between two coordinates using Pythagoras' theorum.
 *
 * @param {Coord} other The other coordinate.
 * @returns {number} The distance between the two coordinates.
 */
Coord.prototype.distFrom = function (other) {
	const distX = Math.pow(this.x - other.x, 2);
	const distY = Math.pow(this.y - other.y, 2);

	return Math.pow(distX + distY, 0.5);
};

/**
 * Adds a vector to the coordinate.
 *
 * @param {Vector} vector The vector to add to the coordinate.
 * @returns {Coord} The new coordinate.
 */
Coord.prototype.add = function (vector) {
	return new Coord(this.x + vector.ax, this.y + vector.ay);
};

module.exports = Coord;

},{}],5:[function(require,module,exports){
const Vector = require('./vector');

/**
 * Generates a slightly wobbly path between two coordinates. The amount of
 * wobbliness can be changed by tweaking the above constants.
 *
 * @param {Coord} from The coordinate to draw from.
 * @param {Coord} to The coordinate to draw to.
 * @param {object} config Configuration options.
 * @returns {Array} An array representing the path to draw.
 */
function generatePath(from, to, config) {
	let path = [
		{ type: 'M', x: from.x, y: from.y }
	];

	let currentPoint = from;
	let currentDirection;

	// Safety to avoid crashing browsers
	let maxRuns = 1000;

	do {

		// This is the perfect direction: also, a boring straight line
		let perfect = Vector.between(currentPoint, to);

		let newDirection;
		if (currentDirection) {
			// This carries on most in the direction the line is currently going, but
			// skews it a little bit back towards the point it's supposed to be going
			// so that it's not too crazy
			newDirection = Vector.average(
					perfect.restrictMagnitude(config.BIAS_TO_PERFECT),
					currentDirection.restrictMagnitude(1 - config.BIAS_TO_PERFECT)
			);
		} else {
			newDirection = perfect;
		}

		newDirection = newDirection
				.restrictMagnitude(config.SEGMENT_LENGTH)
				.randomiseByFactor(config.RANDOM_FACTOR);

		let newPoint = currentPoint.add(newDirection);

		path.push({ type: 'L', x: newPoint.x, y: newPoint.y });
		currentPoint = newPoint;
		currentDirection = newDirection;

	} while (currentPoint.distFrom(to) > config.SEGMENT_LENGTH * 10 && maxRuns--);

	return path;
}

module.exports = generatePath;

},{"./vector":7}],6:[function(require,module,exports){
/**
 * Returns a random number between -0.5 and 0.5. Basically in its own function
 * so that it can be replaced with a different random function if needed.
 *
 * @returns {number} A random number between -0.5 and 0.5.
 */
function random() {
	return Math.random() - 0.5;
}

/**
 * Generate normally distributed random numbers.
 *
 * Only an approximation: actually a Irwinâ€“Hall distribution.
 *
 * @returns {number} A number between -6 and 6 that will approximately map to a
 * normal distribution.
 */
random.normal = function () {
	var total = 0;

	for (let i = 0; i < 12; i++) {
		total += random();
	}

	return total;
};

module.exports = random;

},{}],7:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"./random":6,"dup":2}],8:[function(require,module,exports){
const random = require('../lib/random');

exports.NUMBER_OF_LINES = 1000;

exports.startLength = () => 400 + random() * 500;
exports.endLength = () => 800 + random() * 100;


exports.BACKGROUND_COLOR = '#262819';

// Colors for the path
let opacity = 0.6;

// https://color.adobe.com/Passado1-color-theme-8032401/
exports.COLORS = [
	`rgba(83, 84, 115, ${opacity})`, // blue
	`rgba(214, 216, 209, ${opacity})`, // white
	`rgba(159, 145, 124, ${opacity})`, // cream
	`rgba(142, 55, 48, ${opacity})` // red
];

exports.LINE_WIDTH = 6;


// Line generation config
exports.SEGMENT_LENGTH = 10;
exports.BIAS_TO_PERFECT = 0.5;
exports.RANDOM_FACTOR = 1;

},{"../lib/random":6}],9:[function(require,module,exports){
const Canvas = require('../lib/canvas');
const Vector = require('../lib/Vector');
const generatePath = require('../lib/generatePath');
const config = require('./config');

module.exports = function (selector) {
	const canvas = new Canvas(selector);
	const origin = canvas.origin;

	document.documentElement.style.backgroundColor = config.BACKGROUND_COLOR;
	canvas.fill(config.BACKGROUND_COLOR);

	for (var i = 0; i < config.NUMBER_OF_LINES; i++) {
		let randomDirection = Vector.random();
		let start = origin.add(randomDirection.restrictMagnitude(config.startLength()));
		let end = origin.add(randomDirection.restrictMagnitude(config.endLength()));

		canvas.drawPath({
			path: generatePath(start, end, config),
			width: config.LINE_WIDTH,
			color: config.COLORS[Math.floor(Math.random() * config.COLORS.length)]
		});
	}
};

},{"../lib/Vector":2,"../lib/canvas":3,"../lib/generatePath":5,"./config":8}],10:[function(require,module,exports){
exports.BACKGROUND_COLOR = '#4E4F59';
exports.COLOR = '#F28A5C';

exports.DIGITS = '3' +
	'141592653589793238462643383279502884197169399375105820974944592307816406286' +
	'208998628034825342117067982148086513282306647093844609550582231725359408128481' +
	'117450284102701938521105559644622948954930381964428810975665933446128475648233' +
	'786783165271201909145648566923460348610454326648213393607260249141273724587006' +
	'606315588174881520920962829254091715364367892590360011330530548820466521384146' +
	'951941511609433057270365759591953092186117381932611793105118548074462379962749' +
	'567351885752724891227938183011949129833673362440656643086021394946395224737190' +
	'702179860943702770539217176293176752384674818467669405132000568127145263560827' +
	'785771342757789609173637178721468440901224953430146549585371050792279689258923' +
	'542019956112129021960864034418159813629774771309960518707211349999998372978049' +
	'951059731732816096318595024459455346908302642522308253344685035261931188171010' +
	'003137838752886587533208381420617177669147303598253490428755468731159562863882' +
	'353787593751957781857780532171226806613001927876611195909216420198938095257201' +
	'065485863278865936153381827968230301952035301852968995773622599413891249721775' +
	'283479131515574857242454150695950829533116861727855889075098381754637464939319' +
	'255060400927701671139009848824012858361603563707660104710181942955596198946767' +
	'837449448255379774726847104047534646208046684259069491293313677028989152104752' +
	'162056966024058038150193511253382430035587640247496473263914199272604269922796' +
	'782354781636009341721641219924586315030286182974555706749838505494588586926995' +
	'690927210797509302955321165344987202755960236480665499119881834797753566369807' +
	'426542527862551818417574672890977772793800081647060016145249192173217214772350' +
	'141441973568548161361157352552133475741849468438523323907394143334547762416862' +
	'518983569485562099219222184272550254256887671790494601653466804988627232791786' +
	'085784383827967976681454100953883786360950680064225125205117392984896084128488' +
	'626945604241965285022210661186306744278622039194945047123713786960956364371917' +
	'287467764657573962413890865832645995813390478027590099465764078951269468398352' +
	'595709825822620522489407726719478268482601476990902640136394437455305068203496' +
	'252451749399651431429809190659250937221696461515709858387410597885959772975498' +
	'930161753928468138268683868942774155991855925245953959431049972524680845987273' +
	'644695848653836736222626099124608051243884390451244136549762780797715691435997' +
	'700129616089441694868555848406353422072225828488648158456028506016842739452267' +
	'467678895252138522549954666727823986456596116354886230577456498035593634568174' +
	'324112515076069479451096596094025228879710893145669136867228748940560101503308' +
	'617928680920874760917824938589009714909675985261365549781893129784821682998948' +
	'722658804857564014270477555132379641451523746234364542858444795265867821051141' +
	'354735739523113427166102135969536231442952484937187110145765403590279934403742' +
	'007310578539062198387447808478489683321445713868751943506430218453191048481005' +
	'370614680674919278191197939952061419663428754440643745123718192179998391015919' +
	'561814675142691239748940907186494231961567945208095146550225231603881930142093' +
	'762137855956638937787083039069792077346722182562599661501421503068038447734549' +
	'202605414665925201497442850732518666002132434088190710486331734649651453905796' +
	'268561005508106658796998163574736384052571459102897064140110971206280439039759' +
	'515677157700420337869936007230558763176359421873125147120532928191826186125867' +
	'321579198414848829164470609575270695722091756711672291098169091528017350671274' +
	'858322287183520935396572512108357915136988209144421006751033467110314126711136' +
	'990865851639831501970165151168517143765761835155650884909989859982387345528331' +
	'635507647918535893226185489632132933089857064204675259070915481416549859461637' +
	'180270981994309924488957571282890592323326097299712084433573265489382391193259' +
	'746366730583604142813883032038249037589852437441702913276561809377344403070746' +
	'921120191302033038019762110110044929321516084244485963766983895228684783123552' +
	'658213144957685726243344189303968642624341077322697802807318915441101044682325' +
	'271620105265227211166039666557309254711055785376346682065310989652691862056476' +
	'931257058635662018558100729360659876486117910453348850346113657686753249441668' +
	'039626579787718556084552965412665408530614344431858676975145661406800700237877' +
	'659134401712749470420562230538994561314071127000407854733269939081454664645880' +
	'797270826683063432858785698305235808933065757406795457163775254202114955761581' +
	'400250126228594130216471550979259230990796547376125517656751357517829666454779' +
	'174501129961489030463994713296210734043751895735961458901938971311179042978285' +
	'647503203198691514028708085990480109412147221317947647772622414254854540332157' +
	'185306142288137585043063321751829798662237172159160771669254748738986654949450' +
	'114654062843366393790039769265672146385306736096571209180763832716641627488880' +
	'078692560290228472104031721186082041900042296617119637792133757511495950156604' +
	'963186294726547364252308177036751590673502350728354056704038674351362222477158' +
	'915049530984448933309634087807693259939780541934144737744184263129860809988868' +
	'741326047215695162396586457302163159819319516735381297416772947867242292465436' +
	'680098067692823828068996400482435403701416314965897940924323789690706977942236' +
	'250822168895738379862300159377647165122893578601588161755782973523344604281512' +
	'627203734314653197777416031990665541876397929334419521541341899485444734567383' +
	'162499341913181480927777103863877343177207545654532207770921201905166096280490' +
	'926360197598828161332316663652861932668633606273567630354477628035045077723554' +
	'710585954870279081435624014517180624643626794561275318134078330336254232783944' +
	'975382437205835311477119926063813346776879695970309833913077109870408591337464' +
	'144282277263465947047458784778720192771528073176790770715721344473060570073349' +
	'243693113835049316312840425121925651798069411352801314701304781643788518529092' +
	'854520116583934196562134914341595625865865570552690496520985803385072242648293' +
	'972858478316305777756068887644624824685792603953527734803048029005876075825104' +
	'747091643961362676044925627420420832085661190625454337213153595845068772460290' +
	'161876679524061634252257719542916299193064553779914037340432875262888963995879' +
	'475729174642635745525407909145135711136941091193932519107602082520261879853188' +
	'770584297259167781314969900901921169717372784768472686084900337702424291651300' +
	'500516832336435038951702989392233451722013812806965011784408745196012122859937' +
	'162313017114448464090389064495444006198690754851602632750529834918740786680881';

},{}],11:[function(require,module,exports){
const Canvas = require('../lib/canvas');
const Vector = require('../lib/vector');
const config = require('./config');

module.exports = function (selector) {
	const canvas = new Canvas(selector);
	const origin = canvas.origin;

	document.documentElement.style.backgroundColor = config.BACKGROUND_COLOR;
	canvas.fill(config.BACKGROUND_COLOR);

	const digits = config.DIGITS.split('').map(Number);
	let i = 0;

	digits.forEach(function (digit) {
		const path = [];
		const iAfter = i + digit + 1;

		for (let j = i; j <= iAfter; j++) {
			const direction = Math.PI / 150 * j - Math.PI / 2;
			const magnitude = Math.max(1200 / Math.pow(j / 3500 + 1, 1.5) - 50, 0);

			const vector = Vector.fromDirection(direction, magnitude);
			const coord = origin.add(vector);

			path.push({ type: 'L', x: coord.x, y: coord.y });
		}

		i = iAfter + 3;

		path[0].type = 'M';

		const width = 20 - Math.pow(i / 40, 0.5);

		canvas.drawPath({
			path,
			width,
			color: config.COLOR,
			lineCap: 'round'
		});
	});
};

},{"../lib/canvas":3,"../lib/vector":7,"./config":10}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvaW5kZXguanMiLCJzcmMvbGliL1ZlY3Rvci5qcyIsInNyYy9saWIvY2FudmFzLmpzIiwic3JjL2xpYi9jb29yZC5qcyIsInNyYy9saWIvZ2VuZXJhdGVQYXRoLmpzIiwic3JjL2xpYi9yYW5kb20uanMiLCJzcmMvbm9ybWFsLWxpbmVzL2NvbmZpZy5qcyIsInNyYy9ub3JtYWwtbGluZXMvaW5kZXguanMiLCJzcmMvcGVyaW1ldHJvcy9jb25maWcuanMiLCJzcmMvcGVyaW1ldHJvcy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwid2luZG93Lm5vcm1hbExpbmVzID0gcmVxdWlyZSgnLi9ub3JtYWwtbGluZXMnKTtcbndpbmRvdy5wZXJpbWV0cm9zID0gcmVxdWlyZSgnLi9wZXJpbWV0cm9zJyk7XG4iLCJjb25zdCByYW5kb20gPSByZXF1aXJlKCcuL3JhbmRvbScpO1xuXG4vKipcbiAqIFN0b3JlcyB0aGUgeCBhbmQgeSBkaW1lbnNpb25zIG9mIGEgZXVjbGlkZWFuIHZlY3RvciBpbiB0aGUgY2FydGVzaWFuIHBsYW5lXG4gKiBhbmQgcHJvdmlkZXMgc29tZSB1c2VmdWwgaGVscGVyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYXggVGhlIHggZGltZW5zaW9uIG9mIHRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gYXkgVGhlIHkgZGltZW5zaW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFZlY3RvcihheCwgYXkpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFZlY3RvcikpIHtcblx0XHRyZXR1cm4gbmV3IFZlY3RvcihheCwgYXkpO1xuXHR9XG5cblx0dGhpcy5heCA9IGF4O1xuXHR0aGlzLmF5ID0gYXk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuXG4gKlxuICogQHJldHVybnMge251bWJlcn0gVGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yLlxuICovXG5WZWN0b3IucHJvdG90eXBlLmdldE1hZ25pdHVkZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIE1hdGgucG93KE1hdGgucG93KHRoaXMuYXgsIDIpICsgTWF0aC5wb3codGhpcy5heSwgMiksIDAuNSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgdmVjdG9yIHdpdGggYSBzcGVjaWZpZWQgbWFnbml0dWRlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdNYWduaXR1ZGUgVGhlIG1hZ25pdHVkZSBvZiB0aGUgbmV3IHZlY3Rvci5cbiAqIEByZXR1cm5zIHtWZWN0b3J9IEEgbmV3IHZlY3RvciB3aXRoIHNwZWNpZmllZCBtYWduaXR1ZGUuXG4gKi9cblZlY3Rvci5wcm90b3R5cGUucmVzdHJpY3RNYWduaXR1ZGUgPSBmdW5jdGlvbiAobmV3TWFnbml0dWRlKSB7XG5cdGNvbnN0IHJhdGlvID0gbmV3TWFnbml0dWRlIC8gdGhpcy5nZXRNYWduaXR1ZGUoKTtcblxuXHRyZXR1cm4gbmV3IFZlY3Rvcih0aGlzLmF4ICogcmF0aW8sIHRoaXMuYXkgKiByYXRpbyk7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgYSB2ZWN0b3Igc2xpZ2h0bHkgYnkgYSByYW5kb20gYW1vdW50LiBVc2VzIGEgcmFuZG9tIGZ1bmN0aW9uIHdpdGggYVxuICogbm9ybWFsIGRpc3RyaWJ1dGlvbiwgc28gaXQncyB1c3VhbGx5IG5vdCB0aGF0IGRpZmZlcmVudC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZhY3Rvcj0xXSBTdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIG5vcm1hbCBkaXN0cmlidXRpb25cbiAqIGZ1bmN0aW9uIHVzZWQuXG4gKiBAcmV0dXJucyB7VmVjdG9yfSBTbGlnaHRseSBkaWZmZXJlbnQgdmVjdG9yLlxuICovXG5WZWN0b3IucHJvdG90eXBlLnJhbmRvbWlzZUJ5RmFjdG9yID0gZnVuY3Rpb24gKGZhY3RvciA9IDEpIHtcblx0cmV0dXJuIG5ldyBWZWN0b3IodGhpcy5heCArIHJhbmRvbS5ub3JtYWwoKSAqIGZhY3RvciwgdGhpcy5heSArIHJhbmRvbS5ub3JtYWwoKSAqIGZhY3Rvcik7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHZlY3RvciBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICpcbiAqIEBwYXJhbSB7Q29vcmR9IGZyb20gQ29vcmRpbmF0ZSB0byBjYWxjdWxhdGUgdmVjdG9yIGZyb21cbiAqIEBwYXJhbSB7Q29vcmR9IHRvIENvb3JkaW5hdGUgdG8gY2FsY3VsYXRlIHZlY3RvciB0b1xuICovXG5WZWN0b3IuYmV0d2VlbiA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuXHRyZXR1cm4gbmV3IFZlY3Rvcih0by54IC0gZnJvbS54LCB0by55IC0gZnJvbS55KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXZlcmFnZSBvZiBuIHZlY3RvcnMuXG4gKlxuICogQHBhcmFtIHsuLi5WZWN0b3J9IHZlY3RvcnMgT25lIG9yIG1vcmUgdmVjdG9ycy5cbiAqIEByZXR1cm5zIHtWZWN0b3J9IFRoZSBhdmVyYWdlIHZlY3Rvci5cbiAqL1xuVmVjdG9yLmF2ZXJhZ2UgPSBmdW5jdGlvbiAoLi4udmVjdG9ycykge1xuXHRjb25zdCBheCA9IHZlY3RvcnMucmVkdWNlKChzdW0sIHsgYXggfSkgPT4gc3VtICsgYXgsIDApIC8gdmVjdG9ycy5sZW5ndGg7XG5cdGNvbnN0IGF5ID0gdmVjdG9ycy5yZWR1Y2UoKHN1bSwgeyBheSB9KSA9PiBzdW0gKyBheSwgMCkgLyB2ZWN0b3JzLmxlbmd0aDtcblxuXHRyZXR1cm4gbmV3IFZlY3RvcihheCwgYXkpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIGdvaW5nIDwgMC41IG9uIHRoZSB4IGFuZCB5IGF4ZXMuXG4gKlxuICogQHJldHVybnMge1ZlY3Rvcn0gUmFuZG9tIHZlY3Rvci5cbiAqL1xuVmVjdG9yLnJhbmRvbSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBWZWN0b3IocmFuZG9tKCksIHJhbmRvbSgpKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSB2ZWN0b3IgZnJvbSB0aGUgZGlyZWN0aW9uIGFuZCBtYWduaXR1ZGUgaW5zdGVhZCBvZiBmcm9tIHRoZVxuICogY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIERpcmVjdGlvbiBpbiByYWRpYW5zLlxuICogQHBhcmFtIHtudW1iZXJ9IG1hZ25pdHVkZSBNYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtWZWN0b3J9IEdlbmVyYXRlZCB2ZWN0b3IuXG4gKi9cblZlY3Rvci5mcm9tRGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgbWFnbml0dWRlID0gMSkge1xuXHRjb25zdCBheCA9IG1hZ25pdHVkZSAqIE1hdGguY29zKGRpcmVjdGlvbik7XG5cdGNvbnN0IGF5ID0gbWFnbml0dWRlICogTWF0aC5zaW4oZGlyZWN0aW9uKTtcblx0cmV0dXJuIG5ldyBWZWN0b3IoYXgsIGF5KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yO1xuIiwiY29uc3QgQ29vcmQgPSByZXF1aXJlKCcuL2Nvb3JkJyk7XG5cbi8qKlxuICogQSBzbWFsbCB3cmFwcGVyIGZ1bmN0aW9uIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBtaXggY2FudmFzIGxvZ2ljIHJhbmRvbWx5XG4gKiBpbiB0aGUgcmVzdCBvZiB0aGUgY29kZS4gQmFzaWNhbGx5IG1ha2VzIGV2ZXJ5dGhpbmcgdGVzdGFibGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFRoZSBlbGVtZW50IHRvIGRyYXcgb250by5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDYW52YXMoc2VsZWN0b3IpIHtcblx0dGhpcy5fY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cdHRoaXMuX2NvbnRleHQgPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuXHR0aGlzLm9yaWdpbiA9IG5ldyBDb29yZCh0aGlzLl9jYW52YXMud2lkdGggLyAyLCB0aGlzLl9jYW52YXMuaGVpZ2h0IC8gMik7XG59XG5cblxuLyoqXG4gKiBEcmF3cyBhIHBhdGggdG8gdGhlIGNhbnZhcy4gUGF0aCBzaG91bGQgYmUgYSBzdHJpbmcgc2ltaWxhciB0byBob3cgUmFwaGFlbFxuICogZG9lcyBpdCAoaXQncyBlYXNpZXIgdGVzdGVkKS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBvcHRpb25zOiBwYXRoLCB3aWR0aCBhbmQgY29sb3IuXG4gKi9cbkNhbnZhcy5wcm90b3R5cGUuZHJhd1BhdGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRjb25zdCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcblx0Y29udGV4dC5iZWdpblBhdGgoKTtcblxuXHRvcHRpb25zLnBhdGguZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRzd2l0Y2ggKHBvaW50LnR5cGUpIHtcblx0XHRcdGNhc2UgJ00nOlxuXHRcdFx0XHRjb250ZXh0Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0wnOlxuXHRcdFx0XHRjb250ZXh0LmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcblx0XHR9XG5cdH0pO1xuXG5cdGNvbnRleHQubGluZVdpZHRoID0gb3B0aW9ucy53aWR0aDtcblx0Y29udGV4dC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG5cdGNvbnRleHQubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcblx0Y29udGV4dC5zdHJva2UoKTtcbn07XG5cbi8qKlxuICogRmlsbCB0aGUgZW50aXJlIGNhbnZhcyB3aXRoIGEgc3BlY2lmaWVkIGNvbG9yLiBHb29kIGZvciBiYWNrZ3JvdW5kcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgVGhlIGNvbG9yIHRvIGZpbGwgdGhlIGNhbnZhcyB3aXRoLlxuICovXG5DYW52YXMucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAoY29sb3IpIHtcblx0Y29uc3QgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cdGNvbnRleHQucmVjdCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuXHRjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuXHRjb250ZXh0LmZpbGwoKTtcbn07XG5cbi8qKlxuICogRXhwb3J0IHRoZSBjb250ZW50cyBvZiB0aGUgY2FudmFzIHRvIGEgc3BlY2lmaWVkIGltYWdlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIG1hdGNoaW5nIHRoZSBlbGVtZW50IHRvIGV4cG9ydCB0by5cbiAqL1xuQ2FudmFzLnByb3RvdHlwZS5leHBvcnRUbyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuXHR0aGlzLl9jYW52YXMudG9CbG9iKGZ1bmN0aW9uIChibG9iKSB7XG5cdFx0Y29uc3QgaW1hZ2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcblx0XHRpbWFnZS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHR9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzO1xuIiwiLyoqXG4gKiBTdG9yZXMgdGhlIHggYW5kIHkgcG9zaXRpb25zIG9mIGEgY29vcmRpbmF0ZSBhbmQgcHJvdmlkZXMgc29tZSB1c2VmdWwgaGVscGVyXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHggcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgeSBwb3NpdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb29yZCh4LCB5KSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb29yZCkpIHtcblx0XHRyZXR1cm4gbmV3IENvb3JkKHgsIHkpO1xuXHR9XG5cblx0dGhpcy54ID0geDtcblx0dGhpcy55ID0geTtcbn1cblxuLyoqXG4gKiBXb3JrcyBvdXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzIHVzaW5nIFB5dGhhZ29yYXMnIHRoZW9ydW0uXG4gKlxuICogQHBhcmFtIHtDb29yZH0gb3RoZXIgVGhlIG90aGVyIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIGNvb3JkaW5hdGVzLlxuICovXG5Db29yZC5wcm90b3R5cGUuZGlzdEZyb20gPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0Y29uc3QgZGlzdFggPSBNYXRoLnBvdyh0aGlzLnggLSBvdGhlci54LCAyKTtcblx0Y29uc3QgZGlzdFkgPSBNYXRoLnBvdyh0aGlzLnkgLSBvdGhlci55LCAyKTtcblxuXHRyZXR1cm4gTWF0aC5wb3coZGlzdFggKyBkaXN0WSwgMC41KTtcbn07XG5cbi8qKlxuICogQWRkcyBhIHZlY3RvciB0byB0aGUgY29vcmRpbmF0ZS5cbiAqXG4gKiBAcGFyYW0ge1ZlY3Rvcn0gdmVjdG9yIFRoZSB2ZWN0b3IgdG8gYWRkIHRvIHRoZSBjb29yZGluYXRlLlxuICogQHJldHVybnMge0Nvb3JkfSBUaGUgbmV3IGNvb3JkaW5hdGUuXG4gKi9cbkNvb3JkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmVjdG9yKSB7XG5cdHJldHVybiBuZXcgQ29vcmQodGhpcy54ICsgdmVjdG9yLmF4LCB0aGlzLnkgKyB2ZWN0b3IuYXkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb29yZDtcbiIsImNvbnN0IFZlY3RvciA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgc2xpZ2h0bHkgd29iYmx5IHBhdGggYmV0d2VlbiB0d28gY29vcmRpbmF0ZXMuIFRoZSBhbW91bnQgb2ZcbiAqIHdvYmJsaW5lc3MgY2FuIGJlIGNoYW5nZWQgYnkgdHdlYWtpbmcgdGhlIGFib3ZlIGNvbnN0YW50cy5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkfSBmcm9tIFRoZSBjb29yZGluYXRlIHRvIGRyYXcgZnJvbS5cbiAqIEBwYXJhbSB7Q29vcmR9IHRvIFRoZSBjb29yZGluYXRlIHRvIGRyYXcgdG8uXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwYXRoIHRvIGRyYXcuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUGF0aChmcm9tLCB0bywgY29uZmlnKSB7XG5cdGxldCBwYXRoID0gW1xuXHRcdHsgdHlwZTogJ00nLCB4OiBmcm9tLngsIHk6IGZyb20ueSB9XG5cdF07XG5cblx0bGV0IGN1cnJlbnRQb2ludCA9IGZyb207XG5cdGxldCBjdXJyZW50RGlyZWN0aW9uO1xuXG5cdC8vIFNhZmV0eSB0byBhdm9pZCBjcmFzaGluZyBicm93c2Vyc1xuXHRsZXQgbWF4UnVucyA9IDEwMDA7XG5cblx0ZG8ge1xuXG5cdFx0Ly8gVGhpcyBpcyB0aGUgcGVyZmVjdCBkaXJlY3Rpb246IGFsc28sIGEgYm9yaW5nIHN0cmFpZ2h0IGxpbmVcblx0XHRsZXQgcGVyZmVjdCA9IFZlY3Rvci5iZXR3ZWVuKGN1cnJlbnRQb2ludCwgdG8pO1xuXG5cdFx0bGV0IG5ld0RpcmVjdGlvbjtcblx0XHRpZiAoY3VycmVudERpcmVjdGlvbikge1xuXHRcdFx0Ly8gVGhpcyBjYXJyaWVzIG9uIG1vc3QgaW4gdGhlIGRpcmVjdGlvbiB0aGUgbGluZSBpcyBjdXJyZW50bHkgZ29pbmcsIGJ1dFxuXHRcdFx0Ly8gc2tld3MgaXQgYSBsaXR0bGUgYml0IGJhY2sgdG93YXJkcyB0aGUgcG9pbnQgaXQncyBzdXBwb3NlZCB0byBiZSBnb2luZ1xuXHRcdFx0Ly8gc28gdGhhdCBpdCdzIG5vdCB0b28gY3Jhenlcblx0XHRcdG5ld0RpcmVjdGlvbiA9IFZlY3Rvci5hdmVyYWdlKFxuXHRcdFx0XHRcdHBlcmZlY3QucmVzdHJpY3RNYWduaXR1ZGUoY29uZmlnLkJJQVNfVE9fUEVSRkVDVCksXG5cdFx0XHRcdFx0Y3VycmVudERpcmVjdGlvbi5yZXN0cmljdE1hZ25pdHVkZSgxIC0gY29uZmlnLkJJQVNfVE9fUEVSRkVDVClcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0RpcmVjdGlvbiA9IHBlcmZlY3Q7XG5cdFx0fVxuXG5cdFx0bmV3RGlyZWN0aW9uID0gbmV3RGlyZWN0aW9uXG5cdFx0XHRcdC5yZXN0cmljdE1hZ25pdHVkZShjb25maWcuU0VHTUVOVF9MRU5HVEgpXG5cdFx0XHRcdC5yYW5kb21pc2VCeUZhY3Rvcihjb25maWcuUkFORE9NX0ZBQ1RPUik7XG5cblx0XHRsZXQgbmV3UG9pbnQgPSBjdXJyZW50UG9pbnQuYWRkKG5ld0RpcmVjdGlvbik7XG5cblx0XHRwYXRoLnB1c2goeyB0eXBlOiAnTCcsIHg6IG5ld1BvaW50LngsIHk6IG5ld1BvaW50LnkgfSk7XG5cdFx0Y3VycmVudFBvaW50ID0gbmV3UG9pbnQ7XG5cdFx0Y3VycmVudERpcmVjdGlvbiA9IG5ld0RpcmVjdGlvbjtcblxuXHR9IHdoaWxlIChjdXJyZW50UG9pbnQuZGlzdEZyb20odG8pID4gY29uZmlnLlNFR01FTlRfTEVOR1RIICogMTAgJiYgbWF4UnVucy0tKTtcblxuXHRyZXR1cm4gcGF0aDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZVBhdGg7XG4iLCIvKipcbiAqIFJldHVybnMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gLTAuNSBhbmQgMC41LiBCYXNpY2FsbHkgaW4gaXRzIG93biBmdW5jdGlvblxuICogc28gdGhhdCBpdCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIGRpZmZlcmVudCByYW5kb20gZnVuY3Rpb24gaWYgbmVlZGVkLlxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIC0wLjUgYW5kIDAuNS5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tKCkge1xuXHRyZXR1cm4gTWF0aC5yYW5kb20oKSAtIDAuNTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBub3JtYWxseSBkaXN0cmlidXRlZCByYW5kb20gbnVtYmVycy5cbiAqXG4gKiBPbmx5IGFuIGFwcHJveGltYXRpb246IGFjdHVhbGx5IGEgSXJ3aW7igJNIYWxsIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBIG51bWJlciBiZXR3ZWVuIC02IGFuZCA2IHRoYXQgd2lsbCBhcHByb3hpbWF0ZWx5IG1hcCB0byBhXG4gKiBub3JtYWwgZGlzdHJpYnV0aW9uLlxuICovXG5yYW5kb20ubm9ybWFsID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgdG90YWwgPSAwO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xuXHRcdHRvdGFsICs9IHJhbmRvbSgpO1xuXHR9XG5cblx0cmV0dXJuIHRvdGFsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSByYW5kb207XG4iLCJjb25zdCByYW5kb20gPSByZXF1aXJlKCcuLi9saWIvcmFuZG9tJyk7XG5cbmV4cG9ydHMuTlVNQkVSX09GX0xJTkVTID0gMTAwMDtcblxuZXhwb3J0cy5zdGFydExlbmd0aCA9ICgpID0+IDQwMCArIHJhbmRvbSgpICogNTAwO1xuZXhwb3J0cy5lbmRMZW5ndGggPSAoKSA9PiA4MDAgKyByYW5kb20oKSAqIDEwMDtcblxuXG5leHBvcnRzLkJBQ0tHUk9VTkRfQ09MT1IgPSAnIzI2MjgxOSc7XG5cbi8vIENvbG9ycyBmb3IgdGhlIHBhdGhcbmxldCBvcGFjaXR5ID0gMC42O1xuXG4vLyBodHRwczovL2NvbG9yLmFkb2JlLmNvbS9QYXNzYWRvMS1jb2xvci10aGVtZS04MDMyNDAxL1xuZXhwb3J0cy5DT0xPUlMgPSBbXG5cdGByZ2JhKDgzLCA4NCwgMTE1LCAke29wYWNpdHl9KWAsIC8vIGJsdWVcblx0YHJnYmEoMjE0LCAyMTYsIDIwOSwgJHtvcGFjaXR5fSlgLCAvLyB3aGl0ZVxuXHRgcmdiYSgxNTksIDE0NSwgMTI0LCAke29wYWNpdHl9KWAsIC8vIGNyZWFtXG5cdGByZ2JhKDE0MiwgNTUsIDQ4LCAke29wYWNpdHl9KWAgLy8gcmVkXG5dO1xuXG5leHBvcnRzLkxJTkVfV0lEVEggPSA2O1xuXG5cbi8vIExpbmUgZ2VuZXJhdGlvbiBjb25maWdcbmV4cG9ydHMuU0VHTUVOVF9MRU5HVEggPSAxMDtcbmV4cG9ydHMuQklBU19UT19QRVJGRUNUID0gMC41O1xuZXhwb3J0cy5SQU5ET01fRkFDVE9SID0gMTtcbiIsImNvbnN0IENhbnZhcyA9IHJlcXVpcmUoJy4uL2xpYi9jYW52YXMnKTtcbmNvbnN0IFZlY3RvciA9IHJlcXVpcmUoJy4uL2xpYi9WZWN0b3InKTtcbmNvbnN0IGdlbmVyYXRlUGF0aCA9IHJlcXVpcmUoJy4uL2xpYi9nZW5lcmF0ZVBhdGgnKTtcbmNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdGNvbnN0IGNhbnZhcyA9IG5ldyBDYW52YXMoc2VsZWN0b3IpO1xuXHRjb25zdCBvcmlnaW4gPSBjYW52YXMub3JpZ2luO1xuXG5cdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb25maWcuQkFDS0dST1VORF9DT0xPUjtcblx0Y2FudmFzLmZpbGwoY29uZmlnLkJBQ0tHUk9VTkRfQ09MT1IpO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY29uZmlnLk5VTUJFUl9PRl9MSU5FUzsgaSsrKSB7XG5cdFx0bGV0IHJhbmRvbURpcmVjdGlvbiA9IFZlY3Rvci5yYW5kb20oKTtcblx0XHRsZXQgc3RhcnQgPSBvcmlnaW4uYWRkKHJhbmRvbURpcmVjdGlvbi5yZXN0cmljdE1hZ25pdHVkZShjb25maWcuc3RhcnRMZW5ndGgoKSkpO1xuXHRcdGxldCBlbmQgPSBvcmlnaW4uYWRkKHJhbmRvbURpcmVjdGlvbi5yZXN0cmljdE1hZ25pdHVkZShjb25maWcuZW5kTGVuZ3RoKCkpKTtcblxuXHRcdGNhbnZhcy5kcmF3UGF0aCh7XG5cdFx0XHRwYXRoOiBnZW5lcmF0ZVBhdGgoc3RhcnQsIGVuZCwgY29uZmlnKSxcblx0XHRcdHdpZHRoOiBjb25maWcuTElORV9XSURUSCxcblx0XHRcdGNvbG9yOiBjb25maWcuQ09MT1JTW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvbmZpZy5DT0xPUlMubGVuZ3RoKV1cblx0XHR9KTtcblx0fVxufTtcbiIsImV4cG9ydHMuQkFDS0dST1VORF9DT0xPUiA9ICcjNEU0RjU5JztcbmV4cG9ydHMuQ09MT1IgPSAnI0YyOEE1Qyc7XG5cbmV4cG9ydHMuRElHSVRTID0gJzMnICtcblx0JzE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NzE2OTM5OTM3NTEwNTgyMDk3NDk0NDU5MjMwNzgxNjQwNjI4NicgK1xuXHQnMjA4OTk4NjI4MDM0ODI1MzQyMTE3MDY3OTgyMTQ4MDg2NTEzMjgyMzA2NjQ3MDkzODQ0NjA5NTUwNTgyMjMxNzI1MzU5NDA4MTI4NDgxJyArXG5cdCcxMTc0NTAyODQxMDI3MDE5Mzg1MjExMDU1NTk2NDQ2MjI5NDg5NTQ5MzAzODE5NjQ0Mjg4MTA5NzU2NjU5MzM0NDYxMjg0NzU2NDgyMzMnICtcblx0Jzc4Njc4MzE2NTI3MTIwMTkwOTE0NTY0ODU2NjkyMzQ2MDM0ODYxMDQ1NDMyNjY0ODIxMzM5MzYwNzI2MDI0OTE0MTI3MzcyNDU4NzAwNicgK1xuXHQnNjA2MzE1NTg4MTc0ODgxNTIwOTIwOTYyODI5MjU0MDkxNzE1MzY0MzY3ODkyNTkwMzYwMDExMzMwNTMwNTQ4ODIwNDY2NTIxMzg0MTQ2JyArXG5cdCc5NTE5NDE1MTE2MDk0MzMwNTcyNzAzNjU3NTk1OTE5NTMwOTIxODYxMTczODE5MzI2MTE3OTMxMDUxMTg1NDgwNzQ0NjIzNzk5NjI3NDknICtcblx0JzU2NzM1MTg4NTc1MjcyNDg5MTIyNzkzODE4MzAxMTk0OTEyOTgzMzY3MzM2MjQ0MDY1NjY0MzA4NjAyMTM5NDk0NjM5NTIyNDczNzE5MCcgK1xuXHQnNzAyMTc5ODYwOTQzNzAyNzcwNTM5MjE3MTc2MjkzMTc2NzUyMzg0Njc0ODE4NDY3NjY5NDA1MTMyMDAwNTY4MTI3MTQ1MjYzNTYwODI3JyArXG5cdCc3ODU3NzEzNDI3NTc3ODk2MDkxNzM2MzcxNzg3MjE0Njg0NDA5MDEyMjQ5NTM0MzAxNDY1NDk1ODUzNzEwNTA3OTIyNzk2ODkyNTg5MjMnICtcblx0JzU0MjAxOTk1NjExMjEyOTAyMTk2MDg2NDAzNDQxODE1OTgxMzYyOTc3NDc3MTMwOTk2MDUxODcwNzIxMTM0OTk5OTk5ODM3Mjk3ODA0OScgK1xuXHQnOTUxMDU5NzMxNzMyODE2MDk2MzE4NTk1MDI0NDU5NDU1MzQ2OTA4MzAyNjQyNTIyMzA4MjUzMzQ0Njg1MDM1MjYxOTMxMTg4MTcxMDEwJyArXG5cdCcwMDMxMzc4Mzg3NTI4ODY1ODc1MzMyMDgzODE0MjA2MTcxNzc2NjkxNDczMDM1OTgyNTM0OTA0Mjg3NTU0Njg3MzExNTk1NjI4NjM4ODInICtcblx0JzM1Mzc4NzU5Mzc1MTk1Nzc4MTg1Nzc4MDUzMjE3MTIyNjgwNjYxMzAwMTkyNzg3NjYxMTE5NTkwOTIxNjQyMDE5ODkzODA5NTI1NzIwMScgK1xuXHQnMDY1NDg1ODYzMjc4ODY1OTM2MTUzMzgxODI3OTY4MjMwMzAxOTUyMDM1MzAxODUyOTY4OTk1NzczNjIyNTk5NDEzODkxMjQ5NzIxNzc1JyArXG5cdCcyODM0NzkxMzE1MTU1NzQ4NTcyNDI0NTQxNTA2OTU5NTA4Mjk1MzMxMTY4NjE3Mjc4NTU4ODkwNzUwOTgzODE3NTQ2Mzc0NjQ5MzkzMTknICtcblx0JzI1NTA2MDQwMDkyNzcwMTY3MTEzOTAwOTg0ODgyNDAxMjg1ODM2MTYwMzU2MzcwNzY2MDEwNDcxMDE4MTk0Mjk1NTU5NjE5ODk0Njc2NycgK1xuXHQnODM3NDQ5NDQ4MjU1Mzc5Nzc0NzI2ODQ3MTA0MDQ3NTM0NjQ2MjA4MDQ2Njg0MjU5MDY5NDkxMjkzMzEzNjc3MDI4OTg5MTUyMTA0NzUyJyArXG5cdCcxNjIwNTY5NjYwMjQwNTgwMzgxNTAxOTM1MTEyNTMzODI0MzAwMzU1ODc2NDAyNDc0OTY0NzMyNjM5MTQxOTkyNzI2MDQyNjk5MjI3OTYnICtcblx0Jzc4MjM1NDc4MTYzNjAwOTM0MTcyMTY0MTIxOTkyNDU4NjMxNTAzMDI4NjE4Mjk3NDU1NTcwNjc0OTgzODUwNTQ5NDU4ODU4NjkyNjk5NScgK1xuXHQnNjkwOTI3MjEwNzk3NTA5MzAyOTU1MzIxMTY1MzQ0OTg3MjAyNzU1OTYwMjM2NDgwNjY1NDk5MTE5ODgxODM0Nzk3NzUzNTY2MzY5ODA3JyArXG5cdCc0MjY1NDI1Mjc4NjI1NTE4MTg0MTc1NzQ2NzI4OTA5Nzc3NzI3OTM4MDAwODE2NDcwNjAwMTYxNDUyNDkxOTIxNzMyMTcyMTQ3NzIzNTAnICtcblx0JzE0MTQ0MTk3MzU2ODU0ODE2MTM2MTE1NzM1MjU1MjEzMzQ3NTc0MTg0OTQ2ODQzODUyMzMyMzkwNzM5NDE0MzMzNDU0Nzc2MjQxNjg2MicgK1xuXHQnNTE4OTgzNTY5NDg1NTYyMDk5MjE5MjIyMTg0MjcyNTUwMjU0MjU2ODg3NjcxNzkwNDk0NjAxNjUzNDY2ODA0OTg4NjI3MjMyNzkxNzg2JyArXG5cdCcwODU3ODQzODM4Mjc5Njc5NzY2ODE0NTQxMDA5NTM4ODM3ODYzNjA5NTA2ODAwNjQyMjUxMjUyMDUxMTczOTI5ODQ4OTYwODQxMjg0ODgnICtcblx0JzYyNjk0NTYwNDI0MTk2NTI4NTAyMjIxMDY2MTE4NjMwNjc0NDI3ODYyMjAzOTE5NDk0NTA0NzEyMzcxMzc4Njk2MDk1NjM2NDM3MTkxNycgK1xuXHQnMjg3NDY3NzY0NjU3NTczOTYyNDEzODkwODY1ODMyNjQ1OTk1ODEzMzkwNDc4MDI3NTkwMDk5NDY1NzY0MDc4OTUxMjY5NDY4Mzk4MzUyJyArXG5cdCc1OTU3MDk4MjU4MjI2MjA1MjI0ODk0MDc3MjY3MTk0NzgyNjg0ODI2MDE0NzY5OTA5MDI2NDAxMzYzOTQ0Mzc0NTUzMDUwNjgyMDM0OTYnICtcblx0JzI1MjQ1MTc0OTM5OTY1MTQzMTQyOTgwOTE5MDY1OTI1MDkzNzIyMTY5NjQ2MTUxNTcwOTg1ODM4NzQxMDU5Nzg4NTk1OTc3Mjk3NTQ5OCcgK1xuXHQnOTMwMTYxNzUzOTI4NDY4MTM4MjY4NjgzODY4OTQyNzc0MTU1OTkxODU1OTI1MjQ1OTUzOTU5NDMxMDQ5OTcyNTI0NjgwODQ1OTg3MjczJyArXG5cdCc2NDQ2OTU4NDg2NTM4MzY3MzYyMjI2MjYwOTkxMjQ2MDgwNTEyNDM4ODQzOTA0NTEyNDQxMzY1NDk3NjI3ODA3OTc3MTU2OTE0MzU5OTcnICtcblx0JzcwMDEyOTYxNjA4OTQ0MTY5NDg2ODU1NTg0ODQwNjM1MzQyMjA3MjIyNTgyODQ4ODY0ODE1ODQ1NjAyODUwNjAxNjg0MjczOTQ1MjI2NycgK1xuXHQnNDY3Njc4ODk1MjUyMTM4NTIyNTQ5OTU0NjY2NzI3ODIzOTg2NDU2NTk2MTE2MzU0ODg2MjMwNTc3NDU2NDk4MDM1NTkzNjM0NTY4MTc0JyArXG5cdCczMjQxMTI1MTUwNzYwNjk0Nzk0NTEwOTY1OTYwOTQwMjUyMjg4Nzk3MTA4OTMxNDU2NjkxMzY4NjcyMjg3NDg5NDA1NjAxMDE1MDMzMDgnICtcblx0JzYxNzkyODY4MDkyMDg3NDc2MDkxNzgyNDkzODU4OTAwOTcxNDkwOTY3NTk4NTI2MTM2NTU0OTc4MTg5MzEyOTc4NDgyMTY4Mjk5ODk0OCcgK1xuXHQnNzIyNjU4ODA0ODU3NTY0MDE0MjcwNDc3NTU1MTMyMzc5NjQxNDUxNTIzNzQ2MjM0MzY0NTQyODU4NDQ0Nzk1MjY1ODY3ODIxMDUxMTQxJyArXG5cdCczNTQ3MzU3Mzk1MjMxMTM0MjcxNjYxMDIxMzU5Njk1MzYyMzE0NDI5NTI0ODQ5MzcxODcxMTAxNDU3NjU0MDM1OTAyNzk5MzQ0MDM3NDInICtcblx0JzAwNzMxMDU3ODUzOTA2MjE5ODM4NzQ0NzgwODQ3ODQ4OTY4MzMyMTQ0NTcxMzg2ODc1MTk0MzUwNjQzMDIxODQ1MzE5MTA0ODQ4MTAwNScgK1xuXHQnMzcwNjE0NjgwNjc0OTE5Mjc4MTkxMTk3OTM5OTUyMDYxNDE5NjYzNDI4NzU0NDQwNjQzNzQ1MTIzNzE4MTkyMTc5OTk4MzkxMDE1OTE5JyArXG5cdCc1NjE4MTQ2NzUxNDI2OTEyMzk3NDg5NDA5MDcxODY0OTQyMzE5NjE1Njc5NDUyMDgwOTUxNDY1NTAyMjUyMzE2MDM4ODE5MzAxNDIwOTMnICtcblx0Jzc2MjEzNzg1NTk1NjYzODkzNzc4NzA4MzAzOTA2OTc5MjA3NzM0NjcyMjE4MjU2MjU5OTY2MTUwMTQyMTUwMzA2ODAzODQ0NzczNDU0OScgK1xuXHQnMjAyNjA1NDE0NjY1OTI1MjAxNDk3NDQyODUwNzMyNTE4NjY2MDAyMTMyNDM0MDg4MTkwNzEwNDg2MzMxNzM0NjQ5NjUxNDUzOTA1Nzk2JyArXG5cdCcyNjg1NjEwMDU1MDgxMDY2NTg3OTY5OTgxNjM1NzQ3MzYzODQwNTI1NzE0NTkxMDI4OTcwNjQxNDAxMTA5NzEyMDYyODA0MzkwMzk3NTknICtcblx0JzUxNTY3NzE1NzcwMDQyMDMzNzg2OTkzNjAwNzIzMDU1ODc2MzE3NjM1OTQyMTg3MzEyNTE0NzEyMDUzMjkyODE5MTgyNjE4NjEyNTg2NycgK1xuXHQnMzIxNTc5MTk4NDE0ODQ4ODI5MTY0NDcwNjA5NTc1MjcwNjk1NzIyMDkxNzU2NzExNjcyMjkxMDk4MTY5MDkxNTI4MDE3MzUwNjcxMjc0JyArXG5cdCc4NTgzMjIyODcxODM1MjA5MzUzOTY1NzI1MTIxMDgzNTc5MTUxMzY5ODgyMDkxNDQ0MjEwMDY3NTEwMzM0NjcxMTAzMTQxMjY3MTExMzYnICtcblx0Jzk5MDg2NTg1MTYzOTgzMTUwMTk3MDE2NTE1MTE2ODUxNzE0Mzc2NTc2MTgzNTE1NTY1MDg4NDkwOTk4OTg1OTk4MjM4NzM0NTUyODMzMScgK1xuXHQnNjM1NTA3NjQ3OTE4NTM1ODkzMjI2MTg1NDg5NjMyMTMyOTMzMDg5ODU3MDY0MjA0Njc1MjU5MDcwOTE1NDgxNDE2NTQ5ODU5NDYxNjM3JyArXG5cdCcxODAyNzA5ODE5OTQzMDk5MjQ0ODg5NTc1NzEyODI4OTA1OTIzMjMzMjYwOTcyOTk3MTIwODQ0MzM1NzMyNjU0ODkzODIzOTExOTMyNTknICtcblx0Jzc0NjM2NjczMDU4MzYwNDE0MjgxMzg4MzAzMjAzODI0OTAzNzU4OTg1MjQzNzQ0MTcwMjkxMzI3NjU2MTgwOTM3NzM0NDQwMzA3MDc0NicgK1xuXHQnOTIxMTIwMTkxMzAyMDMzMDM4MDE5NzYyMTEwMTEwMDQ0OTI5MzIxNTE2MDg0MjQ0NDg1OTYzNzY2OTgzODk1MjI4Njg0NzgzMTIzNTUyJyArXG5cdCc2NTgyMTMxNDQ5NTc2ODU3MjYyNDMzNDQxODkzMDM5Njg2NDI2MjQzNDEwNzczMjI2OTc4MDI4MDczMTg5MTU0NDExMDEwNDQ2ODIzMjUnICtcblx0JzI3MTYyMDEwNTI2NTIyNzIxMTE2NjAzOTY2NjU1NzMwOTI1NDcxMTA1NTc4NTM3NjM0NjY4MjA2NTMxMDk4OTY1MjY5MTg2MjA1NjQ3NicgK1xuXHQnOTMxMjU3MDU4NjM1NjYyMDE4NTU4MTAwNzI5MzYwNjU5ODc2NDg2MTE3OTEwNDUzMzQ4ODUwMzQ2MTEzNjU3Njg2NzUzMjQ5NDQxNjY4JyArXG5cdCcwMzk2MjY1Nzk3ODc3MTg1NTYwODQ1NTI5NjU0MTI2NjU0MDg1MzA2MTQzNDQ0MzE4NTg2NzY5NzUxNDU2NjE0MDY4MDA3MDAyMzc4NzcnICtcblx0JzY1OTEzNDQwMTcxMjc0OTQ3MDQyMDU2MjIzMDUzODk5NDU2MTMxNDA3MTEyNzAwMDQwNzg1NDczMzI2OTkzOTA4MTQ1NDY2NDY0NTg4MCcgK1xuXHQnNzk3MjcwODI2NjgzMDYzNDMyODU4Nzg1Njk4MzA1MjM1ODA4OTMzMDY1NzU3NDA2Nzk1NDU3MTYzNzc1MjU0MjAyMTE0OTU1NzYxNTgxJyArXG5cdCc0MDAyNTAxMjYyMjg1OTQxMzAyMTY0NzE1NTA5NzkyNTkyMzA5OTA3OTY1NDczNzYxMjU1MTc2NTY3NTEzNTc1MTc4Mjk2NjY0NTQ3NzknICtcblx0JzE3NDUwMTEyOTk2MTQ4OTAzMDQ2Mzk5NDcxMzI5NjIxMDczNDA0Mzc1MTg5NTczNTk2MTQ1ODkwMTkzODk3MTMxMTE3OTA0Mjk3ODI4NScgK1xuXHQnNjQ3NTAzMjAzMTk4NjkxNTE0MDI4NzA4MDg1OTkwNDgwMTA5NDEyMTQ3MjIxMzE3OTQ3NjQ3NzcyNjIyNDE0MjU0ODU0NTQwMzMyMTU3JyArXG5cdCcxODUzMDYxNDIyODgxMzc1ODUwNDMwNjMzMjE3NTE4Mjk3OTg2NjIyMzcxNzIxNTkxNjA3NzE2NjkyNTQ3NDg3Mzg5ODY2NTQ5NDk0NTAnICtcblx0JzExNDY1NDA2Mjg0MzM2NjM5Mzc5MDAzOTc2OTI2NTY3MjE0NjM4NTMwNjczNjA5NjU3MTIwOTE4MDc2MzgzMjcxNjY0MTYyNzQ4ODg4MCcgK1xuXHQnMDc4NjkyNTYwMjkwMjI4NDcyMTA0MDMxNzIxMTg2MDgyMDQxOTAwMDQyMjk2NjE3MTE5NjM3NzkyMTMzNzU3NTExNDk1OTUwMTU2NjA0JyArXG5cdCc5NjMxODYyOTQ3MjY1NDczNjQyNTIzMDgxNzcwMzY3NTE1OTA2NzM1MDIzNTA3MjgzNTQwNTY3MDQwMzg2NzQzNTEzNjIyMjI0NzcxNTgnICtcblx0JzkxNTA0OTUzMDk4NDQ0ODkzMzMwOTYzNDA4NzgwNzY5MzI1OTkzOTc4MDU0MTkzNDE0NDczNzc0NDE4NDI2MzEyOTg2MDgwOTk4ODg2OCcgK1xuXHQnNzQxMzI2MDQ3MjE1Njk1MTYyMzk2NTg2NDU3MzAyMTYzMTU5ODE5MzE5NTE2NzM1MzgxMjk3NDE2NzcyOTQ3ODY3MjQyMjkyNDY1NDM2JyArXG5cdCc2ODAwOTgwNjc2OTI4MjM4MjgwNjg5OTY0MDA0ODI0MzU0MDM3MDE0MTYzMTQ5NjU4OTc5NDA5MjQzMjM3ODk2OTA3MDY5Nzc5NDIyMzYnICtcblx0JzI1MDgyMjE2ODg5NTczODM3OTg2MjMwMDE1OTM3NzY0NzE2NTEyMjg5MzU3ODYwMTU4ODE2MTc1NTc4Mjk3MzUyMzM0NDYwNDI4MTUxMicgK1xuXHQnNjI3MjAzNzM0MzE0NjUzMTk3Nzc3NDE2MDMxOTkwNjY1NTQxODc2Mzk3OTI5MzM0NDE5NTIxNTQxMzQxODk5NDg1NDQ0NzM0NTY3MzgzJyArXG5cdCcxNjI0OTkzNDE5MTMxODE0ODA5Mjc3NzcxMDM4NjM4NzczNDMxNzcyMDc1NDU2NTQ1MzIyMDc3NzA5MjEyMDE5MDUxNjYwOTYyODA0OTAnICtcblx0JzkyNjM2MDE5NzU5ODgyODE2MTMzMjMxNjY2MzY1Mjg2MTkzMjY2ODYzMzYwNjI3MzU2NzYzMDM1NDQ3NzYyODAzNTA0NTA3NzcyMzU1NCcgK1xuXHQnNzEwNTg1OTU0ODcwMjc5MDgxNDM1NjI0MDE0NTE3MTgwNjI0NjQzNjI2Nzk0NTYxMjc1MzE4MTM0MDc4MzMwMzM2MjU0MjMyNzgzOTQ0JyArXG5cdCc5NzUzODI0MzcyMDU4MzUzMTE0NzcxMTk5MjYwNjM4MTMzNDY3NzY4Nzk2OTU5NzAzMDk4MzM5MTMwNzcxMDk4NzA0MDg1OTEzMzc0NjQnICtcblx0JzE0NDI4MjI3NzI2MzQ2NTk0NzA0NzQ1ODc4NDc3ODcyMDE5Mjc3MTUyODA3MzE3Njc5MDc3MDcxNTcyMTM0NDQ3MzA2MDU3MDA3MzM0OScgK1xuXHQnMjQzNjkzMTEzODM1MDQ5MzE2MzEyODQwNDI1MTIxOTI1NjUxNzk4MDY5NDExMzUyODAxMzE0NzAxMzA0NzgxNjQzNzg4NTE4NTI5MDkyJyArXG5cdCc4NTQ1MjAxMTY1ODM5MzQxOTY1NjIxMzQ5MTQzNDE1OTU2MjU4NjU4NjU1NzA1NTI2OTA0OTY1MjA5ODU4MDMzODUwNzIyNDI2NDgyOTMnICtcblx0Jzk3Mjg1ODQ3ODMxNjMwNTc3Nzc1NjA2ODg4NzY0NDYyNDgyNDY4NTc5MjYwMzk1MzUyNzczNDgwMzA0ODAyOTAwNTg3NjA3NTgyNTEwNCcgK1xuXHQnNzQ3MDkxNjQzOTYxMzYyNjc2MDQ0OTI1NjI3NDIwNDIwODMyMDg1NjYxMTkwNjI1NDU0MzM3MjEzMTUzNTk1ODQ1MDY4NzcyNDYwMjkwJyArXG5cdCcxNjE4NzY2Nzk1MjQwNjE2MzQyNTIyNTc3MTk1NDI5MTYyOTkxOTMwNjQ1NTM3Nzk5MTQwMzczNDA0MzI4NzUyNjI4ODg5NjM5OTU4NzknICtcblx0JzQ3NTcyOTE3NDY0MjYzNTc0NTUyNTQwNzkwOTE0NTEzNTcxMTEzNjk0MTA5MTE5MzkzMjUxOTEwNzYwMjA4MjUyMDI2MTg3OTg1MzE4OCcgK1xuXHQnNzcwNTg0Mjk3MjU5MTY3NzgxMzE0OTY5OTAwOTAxOTIxMTY5NzE3MzcyNzg0NzY4NDcyNjg2MDg0OTAwMzM3NzAyNDI0MjkxNjUxMzAwJyArXG5cdCc1MDA1MTY4MzIzMzY0MzUwMzg5NTE3MDI5ODkzOTIyMzM0NTE3MjIwMTM4MTI4MDY5NjUwMTE3ODQ0MDg3NDUxOTYwMTIxMjI4NTk5MzcnICtcblx0JzE2MjMxMzAxNzExNDQ0ODQ2NDA5MDM4OTA2NDQ5NTQ0NDAwNjE5ODY5MDc1NDg1MTYwMjYzMjc1MDUyOTgzNDkxODc0MDc4NjY4MDg4MSc7XG4iLCJjb25zdCBDYW52YXMgPSByZXF1aXJlKCcuLi9saWIvY2FudmFzJyk7XG5jb25zdCBWZWN0b3IgPSByZXF1aXJlKCcuLi9saWIvdmVjdG9yJyk7XG5jb25zdCBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuXHRjb25zdCBjYW52YXMgPSBuZXcgQ2FudmFzKHNlbGVjdG9yKTtcblx0Y29uc3Qgb3JpZ2luID0gY2FudmFzLm9yaWdpbjtcblxuXHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29uZmlnLkJBQ0tHUk9VTkRfQ09MT1I7XG5cdGNhbnZhcy5maWxsKGNvbmZpZy5CQUNLR1JPVU5EX0NPTE9SKTtcblxuXHRjb25zdCBkaWdpdHMgPSBjb25maWcuRElHSVRTLnNwbGl0KCcnKS5tYXAoTnVtYmVyKTtcblx0bGV0IGkgPSAwO1xuXG5cdGRpZ2l0cy5mb3JFYWNoKGZ1bmN0aW9uIChkaWdpdCkge1xuXHRcdGNvbnN0IHBhdGggPSBbXTtcblx0XHRjb25zdCBpQWZ0ZXIgPSBpICsgZGlnaXQgKyAxO1xuXG5cdFx0Zm9yIChsZXQgaiA9IGk7IGogPD0gaUFmdGVyOyBqKyspIHtcblx0XHRcdGNvbnN0IGRpcmVjdGlvbiA9IE1hdGguUEkgLyAxNTAgKiBqIC0gTWF0aC5QSSAvIDI7XG5cdFx0XHRjb25zdCBtYWduaXR1ZGUgPSBNYXRoLm1heCgxMjAwIC8gTWF0aC5wb3coaiAvIDM1MDAgKyAxLCAxLjUpIC0gNTAsIDApO1xuXG5cdFx0XHRjb25zdCB2ZWN0b3IgPSBWZWN0b3IuZnJvbURpcmVjdGlvbihkaXJlY3Rpb24sIG1hZ25pdHVkZSk7XG5cdFx0XHRjb25zdCBjb29yZCA9IG9yaWdpbi5hZGQodmVjdG9yKTtcblxuXHRcdFx0cGF0aC5wdXNoKHsgdHlwZTogJ0wnLCB4OiBjb29yZC54LCB5OiBjb29yZC55IH0pO1xuXHRcdH1cblxuXHRcdGkgPSBpQWZ0ZXIgKyAzO1xuXG5cdFx0cGF0aFswXS50eXBlID0gJ00nO1xuXG5cdFx0Y29uc3Qgd2lkdGggPSAyMCAtIE1hdGgucG93KGkgLyA0MCwgMC41KTtcblxuXHRcdGNhbnZhcy5kcmF3UGF0aCh7XG5cdFx0XHRwYXRoLFxuXHRcdFx0d2lkdGgsXG5cdFx0XHRjb2xvcjogY29uZmlnLkNPTE9SLFxuXHRcdFx0bGluZUNhcDogJ3JvdW5kJ1xuXHRcdH0pO1xuXHR9KTtcbn07XG4iXX0=
